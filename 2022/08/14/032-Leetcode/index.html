<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>（持续更新中...）Leetcode 周赛记录 | “干杯( ﾟ-ﾟ)っロ”</title><meta name="author" content="SvyJ"><meta name="copyright" content="SvyJ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="慢慢刷题慢慢补充~ 写在最前面的小笔记（持续补充）：（1）ASCII 码表：ASCII码中文站（2）字符串数组用 strings.sort() 排序，sorted 不适用（3）Python 字符串 string 类型不支持更改（4）初始化一个字典用 collections.defaultdict（5）有序列表可以用 sortedcontainers.SortedList   2022-08-14">
<meta property="og:type" content="article">
<meta property="og:title" content="（持续更新中...）Leetcode 周赛记录">
<meta property="og:url" content="http://example.com/2022/08/14/032-Leetcode/index.html">
<meta property="og:site_name" content="“干杯( ﾟ-ﾟ)っロ”">
<meta property="og:description" content="慢慢刷题慢慢补充~ 写在最前面的小笔记（持续补充）：（1）ASCII 码表：ASCII码中文站（2）字符串数组用 strings.sort() 排序，sorted 不适用（3）Python 字符串 string 类型不支持更改（4）初始化一个字典用 collections.defaultdict（5）有序列表可以用 sortedcontainers.SortedList   2022-08-14">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg">
<meta property="article:published_time" content="2022-08-14T07:16:58.000Z">
<meta property="article:modified_time" content="2022-08-14T07:16:58.000Z">
<meta property="article:author" content="SvyJ">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg"><link rel="shortcut icon" href="/images/logo.png"><link rel="canonical" href="http://example.com/2022/08/14/032-Leetcode/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: SvyJ","link":"链接: ","source":"来源: “干杯( ﾟ-ﾟ)っロ”","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '（持续更新中...）Leetcode 周赛记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-14 15:16:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_3054216_qov50ieeupn.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/07/24/PEyfxB56HsbACYo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg')"><nav id="nav"><span id="blog-info"><a href="/" title="“干杯( ﾟ-ﾟ)っロ”"><img class="site-icon" src="/images/logo.png"/><span class="site-name">“干杯( ﾟ-ﾟ)っロ”</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">（持续更新中...）Leetcode 周赛记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-14T07:16:58.000Z" title="发表于 2022-08-14 15:16:58">2022-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-14T07:16:58.000Z" title="更新于 2022-08-14 15:16:58">2022-08-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="（持续更新中...）Leetcode 周赛记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li>慢慢刷题慢慢补充~</li>
<li>写在最前面的小笔记（持续补充）：<br>（1）<code>ASCII</code> 码表：<a target="_blank" rel="noopener" href="https://www.habaijian.com/">ASCII码中文站</a><br>（2）字符串数组用 <code>strings.sort()</code> 排序，<code>sorted</code> 不适用<br>（3）<code>Python</code> 字符串 <code>string</code> 类型不支持更改<br>（4）初始化一个字典用 <code>collections.defaultdict</code><br>（5）有序列表可以用 <code>sortedcontainers.SortedList</code></li>
</ul>
<hr>
<h1 id="2022-08-14-第-306-场周赛"><a href="#2022-08-14-第-306-场周赛" class="headerlink" title="2022-08-14 第 306 场周赛"></a>2022-08-14 第 306 场周赛</h1><h2 id="T1-6148-矩阵中的局部最大值"><a href="#T1-6148-矩阵中的局部最大值" class="headerlink" title="T1 6148. 矩阵中的局部最大值"></a>T1 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-306/problems/largest-local-values-in-a-matrix/">6148. 矩阵中的局部最大值</a></h2><blockquote>
<p><strong>模拟最大池化，Deep Learning 人狂喜</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestLocal</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        self.grid = grid<br>        maxLocal = [[<span class="hljs-number">0</span>]*(n-<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>):<br>                maxLocal[i][j] = self.findMax(i, i+<span class="hljs-number">2</span>, j, j+<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> maxLocal<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findMax</span>(<span class="hljs-params">self, x1, x2, y1, y2</span>):<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(x1, x2+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(y1, y2+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> self.grid[i][j] &gt; ret:<br>                    ret = self.grid[i][j]<br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>

<h2 id="T2-6149-边积分最高的节点"><a href="#T2-6149-边积分最高的节点" class="headerlink" title="T2 6149. 边积分最高的节点"></a>T2 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-306/problems/node-with-highest-edge-score/">6149. 边积分最高的节点</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">edgeScore</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(edges)<br>        ret = [<span class="hljs-number">0</span>]*n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            ret[edges[i]] += i<br>        <span class="hljs-keyword">return</span> ret.index(<span class="hljs-built_in">max</span>(ret))<br></code></pre></td></tr></table></figure>

<h2 id="T3-6150-根据模式串构造最小数字"><a href="#T3-6150-根据模式串构造最小数字" class="headerlink" title="T3 6150. 根据模式串构造最小数字"></a>T3 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-306/problems/construct-smallest-number-from-di-string/">6150. 根据模式串构造最小数字</a></h2><p>我以为只有 T4 是原题，没想到 T3 居然也是原题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-permutation/">484. 寻找排列</a>，而且还欺负我是穷逼不是会员看不到原题。</p>
<p><img src="https://s2.loli.net/2022/08/14/bkprtLgSMixRBEA.jpg"></p>
<h2 id="T4-6151-统计特殊整数"><a href="#T4-6151-统计特殊整数" class="headerlink" title="T4 6151. 统计特殊整数"></a>T4 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-306/problems/count-special-integers/">6151. 统计特殊整数</a></h2><p>看了赛后讨论区才发现是原题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-with-repeated-digits/">1012. 至少有 1 位重复的数字</a>，没意思。我还纳闷大家 Hard 题 A 得这么快。</p>
<hr>
<h1 id="2022-08-07-第-305-场周赛"><a href="#2022-08-07-第-305-场周赛" class="headerlink" title="2022-08-07 第 305 场周赛"></a>2022-08-07 第 305 场周赛</h1><p><strong>动态规划专场</strong>了属于是，刚好我 <code>DP</code> 比较菜</p>
<h2 id="T1-6136-算术三元组的数目"><a href="#T1-6136-算术三元组的数目" class="headerlink" title="T1 6136. 算术三元组的数目"></a>T1 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/number-of-arithmetic-triplets/">6136. 算术三元组的数目</a></h2><p>给你一个下标从 <code>0</code> 开始、<strong>严格递增</strong> 的整数数组 <code>nums</code> 和一个正整数 <code>diff</code> 。如果满足下述全部条件，则三元组 <code>(i, j, k)</code> 就是一个 <strong>算术三元组</strong> ：</p>
<ul>
<li><code>i &lt; j &lt; k</code> ，</li>
<li><code>nums[j] - nums[i] == diff</code> 且</li>
<li><code>nums[k] - nums[j] == diff</code></li>
</ul>
<p>返回不同 <strong>算术三元组</strong> 的数目。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [0,1,4,6,7,10], diff &#x3D; 3<br><strong>输出</strong>：2<br><strong>解释</strong>：<br>(1, 2, 4) 是算术三元组：7 - 4 &#x3D;&#x3D; 3 且 4 - 1 &#x3D;&#x3D; 3 。<br>(2, 4, 5) 是算术三元组：10 - 7 &#x3D;&#x3D; 3 且 7 - 4 &#x3D;&#x3D; 3 。</p>
</blockquote>
<p>提示：<br>$3 \leq$ <code>nums.length</code> $\leq 200$<br>$0 \leq$ <code>nums[i]</code> $\leq 200$<br>$1 \leq$ <code>diff</code> $\leq 50$<br><code>nums</code> <strong>严格</strong> 递增</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arithmeticTriplets</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], diff: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        self.nums = nums<br>        self.n = <span class="hljs-built_in">len</span>(self.nums)<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n):<br>            j = self.helper(i+<span class="hljs-number">1</span>, self.nums[i]+diff)<br>            k = self.helper(i+<span class="hljs-number">1</span>, self.nums[i]+<span class="hljs-number">2</span>*diff)<br>            <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> k &gt;= <span class="hljs-number">0</span>:<br>                ret += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ret<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">self, startIndex, target</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(startIndex, self.n):<br>            <span class="hljs-keyword">if</span> self.nums[i] == target:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="T2-6139-受限条件下可到达节点的数目"><a href="#T2-6139-受限条件下可到达节点的数目" class="headerlink" title="T2 6139. 受限条件下可到达节点的数目"></a>T2 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/reachable-nodes-with-restrictions/">6139. 受限条件下可到达节点的数目</a></h2><p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p>
<p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 <strong>受限</strong> 节点。</p>
<p>在不访问受限节点的前提下，返回你可以从节点 <code>0</code> 到达的 <strong>最多</strong> 节点数目。</p>
<p>注意，节点 <code>0</code> <strong>不</strong> 会标记为受限节点。</p>
<blockquote>
<p><strong>输入</strong>：n &#x3D; 7, edges &#x3D; [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted &#x3D; [4,5]<br><strong>输出</strong>：4<br><strong>解释</strong>：上图所示正是这棵树。<br>在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。<br><img src="https://s2.loli.net/2022/08/07/Je27Wnlz8X9siRr.png"></p>
</blockquote>
<p>提示：<br>$2 \leq$ <code>n</code> $\leq 10^{5}$<br><code>edges.length</code> $&#x3D;&#x3D; n - 1$<br><code>edges[i].length</code> $&#x3D;&#x3D; 2$<br>$0 \leq a_{i}, b_{i} &lt; n$<br>$a_{i} !&#x3D; b_{i}$<br><code>edges</code> 表示一棵有效的树<br>$1 \leq$ <code>restricted.length</code> $&lt; n$<br>$1 \leq$ <code>restricted[i]</code> $&lt; n$<br><code>restricted</code> 中的所有值 <strong>互不相同</strong></p>
<blockquote>
<p>从节点 <code>0</code> 开始 <code>BFS</code> 即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reachableNodes</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], restricted: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        restr_flag = [<span class="hljs-number">0</span>]*n<br>        paths = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        visited = [<span class="hljs-number">0</span>]*n<br>        <br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> restricted:<br>            restr_flag[node] = <span class="hljs-number">1</span><br>            <br>        <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-keyword">if</span> restr_flag[edge[<span class="hljs-number">0</span>]] <span class="hljs-keyword">or</span> restr_flag[edge[<span class="hljs-number">1</span>]]:<br>                <span class="hljs-keyword">continue</span><br>            paths[edge[<span class="hljs-number">0</span>]].append(edge[<span class="hljs-number">1</span>])<br>            paths[edge[<span class="hljs-number">1</span>]].append(edge[<span class="hljs-number">0</span>])<br>            <br>        queue = [<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.pop(<span class="hljs-number">0</span>)<br>            visited[node] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> paths[node]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[nd]:<br>                    queue.append(nd)<br>        <span class="hljs-keyword">return</span> visited.count(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>


<h2 id="T3-6137-检查数组是否存在有效划分"><a href="#T3-6137-检查数组是否存在有效划分" class="headerlink" title="T3 6137. 检查数组是否存在有效划分"></a>T3 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/check-if-there-is-a-valid-partition-for-the-array/">6137. 检查数组是否存在有效划分</a></h2><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，你必须将数组划分为一个或多个 <strong>连续</strong> 子数组。</p>
<p>如果获得的这些子数组中每个都能满足下述条件 <strong>之一</strong> ，则可以称其为数组的一种 <strong>有效</strong> 划分：</p>
<ul>
<li>子数组 <strong>恰</strong> 由 <code>2</code> 个相等元素组成，例如，子数组 <code>[2,2]</code> 。</li>
<li>子数组 <strong>恰</strong> 由 <code>3</code> 个相等元素组成，例如，子数组 <code>[4,4,4]</code> 。</li>
<li>子数组 <strong>恰</strong> 由 <code>3</code> 个连续递增元素组成，并且相邻元素之间的差值为 <code>1</code> 。例如，子数组 <code>[3,4,5]</code> ，但是子数组 <code>[1,3,5]</code> 不符合要求。</li>
</ul>
<p>如果数组 <strong>至少</strong> 存在一种有效划分，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [4,4,4,5,6]<br><strong>输出</strong>：true<br><strong>解释</strong>：数组可以划分成子数组 [4,4] 和 [4,5,6] 。<br>这是一种有效划分，所以返回 true 。</p>
</blockquote>
<p>提示：<br>$2 \leq$ <code>nums.length</code> $\leq 10^{5}$<br>$1 \leq$ <code>nums[i]</code> $\leq 10^{6}$</p>
<blockquote>
<p>数据量小的情况下可以用递归，但本题用递归会 <code>T</code>……</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validPartition</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">2</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-number">1</span>] == nums[<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(nums) &gt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">2</span>]:<br>                <span class="hljs-keyword">return</span> self.validPartition(nums[<span class="hljs-number">2</span>:]) <span class="hljs-keyword">or</span> self.validPartition(nums[<span class="hljs-number">3</span>:])<br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[<span class="hljs-number">0</span>] != nums[<span class="hljs-number">2</span>]:<br>                <span class="hljs-keyword">return</span> self.validPartition(nums[<span class="hljs-number">2</span>:])<br>            <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[<span class="hljs-number">1</span>] == nums[<span class="hljs-number">2</span>]-<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> self.validPartition(nums[<span class="hljs-number">3</span>:])<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>动态规划：遍历数组中的所有元素，判断该元素及其前的所有元素是否合法，更新当前的状态即可，当全部元素遍历完后即为最后结果。<br>（1）<code>dp</code> 数组全部初始化为 <code>False</code>：<br><code>dp[0] = True, dp[1] = False</code>；<br>若 <code>nums[0] == nums[1]</code>（<strong>条件一</strong>）, 则 <code>dp[2] = True</code>，否则为 <code>False</code>；<br>若 <code>nums[0] == nums[1] == nums[2]</code>（<strong>条件二</strong>）或 <code>nums[0]+1 == nums[1] == nums[2]-1</code>（<strong>条件三</strong>）, 则 <code>dp[3] = True</code>，否则为 <code>False</code>；<br>（2）对于 <code>nums[i]</code>，有以下三种方式处理，状态转移规则为：<br>a. 若 <code>nums[i]</code> 与 <code>nums[i-1]</code> 按<strong>条件一</strong>组成子数组，则 <code>dp[i] = dp[i-2] &amp; nums[i-1] == nums[i]</code>；<br>b. 若 <code>nums[i]</code> 与 <code>nums[i-1]</code>，<code>nums[i-2]</code> 按<strong>条件二</strong>组成子数组，则 <code>dp[i] = dp[i-3] &amp; nums[i-2] == nums[i-1] == nums[i]</code>；<br>c. 若 <code>nums[i]</code> 与 <code>nums[i-1]</code>，<code>nums[i-2]</code> 按<strong>条件三</strong>组成子数组，则 <code>dp[i] = dp[i-3] &amp; nums[i-2]+1 == nums[i-1] == nums[i]-1</code>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validPartition</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">elif</span> n == <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>] == nums[<span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span> == nums[<span class="hljs-number">1</span>] == nums[<span class="hljs-number">2</span>]-<span class="hljs-number">1</span><br>        <br>        dp = [<span class="hljs-literal">False</span>]*n<br>        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]<br>        dp[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>] == nums[<span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span> == nums[<span class="hljs-number">1</span>] == nums[<span class="hljs-number">2</span>]-<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n):<br>            <span class="hljs-keyword">if</span> dp[i-<span class="hljs-number">2</span>] <span class="hljs-keyword">and</span> nums[i-<span class="hljs-number">1</span>] == nums[i]:<br>                dp[i] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> dp[i-<span class="hljs-number">3</span>] <span class="hljs-keyword">and</span> nums[i-<span class="hljs-number">2</span>] == nums[i-<span class="hljs-number">1</span>] == nums[i]:<br>                dp[i] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> dp[i-<span class="hljs-number">3</span>] <span class="hljs-keyword">and</span> nums[i-<span class="hljs-number">2</span>]+<span class="hljs-number">1</span> == nums[i-<span class="hljs-number">1</span>] == nums[i]-<span class="hljs-number">1</span>:<br>                dp[i] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h2 id="T4-6138-最长理想子序列"><a href="#T4-6138-最长理想子序列" class="headerlink" title="T4 6138. 最长理想子序列"></a>T4 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-305/problems/longest-ideal-subsequence/">6138. 最长理想子序列</a></h2><p>给你一个由小写字母组成的字符串 <code>s</code> ，和一个整数 <code>k</code> 。如果满足下述条件，则可以将字符串 <code>t</code> 视作是 <strong>理想字符串</strong> ：</p>
<p><code>t</code> 是字符串 <code>s</code> 的一个子序列。<br><code>t</code> 中每两个 <strong>相邻</strong> 字母在字母表中位次的绝对差值小于或等于 <code>k</code> 。<br>返回 <strong>最长</strong> 理想字符串的长度。</p>
<p>字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。</p>
<p><strong>注意</strong>：字母表顺序不会循环。例如，<code>&#39;a&#39;</code> 和 <code>&#39;z&#39;</code> 在字母表中位次的绝对差值是 <code>25</code> ，而不是 <code>1</code> 。</p>
<blockquote>
<p><strong>输入</strong>：s &#x3D; “acfgbd”, k &#x3D; 2<br><strong>输出</strong>：4<br><strong>解释</strong>：最长理想字符串是 “acbd” 。该字符串长度为 4 ，所以返回 4 。<br>注意 “acfgbd” 不是理想字符串，因为 ‘c’ 和 ‘f’ 的字母表位次差值为 3 。</p>
</blockquote>
<p>提示：<br>$1 \leq$ <code>s.length</code> $\leq 10^{5}$<br>$0 \leq$ <code>k</code> $\leq 25$<br><code>s</code> 由小写英文字母组成</p>
<blockquote>
<p>动态规划：<code>dp</code> 数组记录以某一字母结尾的最长理想字符串长度；对于 <code>s[i]</code>，其在字母表中的索引为 <code>t</code>，以其结尾的最大长度，仅需考虑其 <code>[t-k, t+k]</code> 范围内的字母即可，而无需考虑 <code>s[i]</code> 之前的所有字母。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestIdealString</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            t = <span class="hljs-built_in">ord</span>(s[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>            dp[t] = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(dp[<span class="hljs-built_in">max</span>(t-k, <span class="hljs-number">0</span>): t+k+<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="2022-07-31-第-304-场周赛"><a href="#2022-07-31-第-304-场周赛" class="headerlink" title="2022-07-31 第 304 场周赛"></a>2022-07-31 第 304 场周赛</h1><h2 id="T1-6132-使数组中所有元素都等于零"><a href="#T1-6132-使数组中所有元素都等于零" class="headerlink" title="T1 6132. 使数组中所有元素都等于零"></a>T1 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-304/problems/make-array-zero-by-subtracting-equal-amounts/">6132. 使数组中所有元素都等于零</a></h2><p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>
<p>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。<br><code>nums</code> 中的每个正整数都减去 <code>x</code>。<br>返回使 <code>nums</code> 中所有元素都等于 <code>0</code> 需要的 <strong>最少</strong> 操作数。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [1,5,0,3,5]<br><strong>输出</strong>：3<br><strong>解释</strong>：<br>第一步操作：选出 x &#x3D; 1 ，之后 nums &#x3D; [0,4,0,2,4] 。<br>第二步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,2,0,0,2] 。<br>第三步操作：选出 x &#x3D; 2 ，之后 nums &#x3D; [0,0,0,0,0] 。</p>
</blockquote>
<p>提示：<br>$1 \leq$ <code>nums.length</code> $\leq 100$<br>$0 \leq$ <code>nums[i]</code> $\leq 100$</p>
<blockquote>
<p><strong>解题思路</strong>：<br><strong>模拟</strong>：每次减掉数组中的最小非零元素即可，直到全部置零</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumOperations</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums.sort()<br>        k = self.helper(nums)<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> k:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span>:<br>                    nums[i] -= k<br>            k = self.helper(nums)<br>            ret += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ret<br>        <br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> num<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h2 id="T2-6133-分组的最大数量"><a href="#T2-6133-分组的最大数量" class="headerlink" title="T2 6133. 分组的最大数量"></a>T2 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-304/problems/maximum-number-of-groups-entering-a-competition/">6133. 分组的最大数量</a></h2><p>给你一个正整数数组 <code>grades</code> ，表示大学中一些学生的成绩。你打算将 <strong>所有</strong> 学生分为一些 <strong>有序</strong> 的非空分组，其中分组间的顺序满足以下全部条件：</p>
<p>第 <code>i</code> 个分组中的学生总成绩 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总成绩，对所有组均成立（除了最后一组）。<br>第 <code>i</code> 个分组中的学生总数 <strong>小于</strong> 第 <code>(i + 1)</code> 个分组中的学生总数，对所有组均成立（除了最后一组）。<br>返回可以形成的 <strong>最大</strong> 组数。</p>
<blockquote>
<p><strong>输入</strong>：grades &#x3D; [10,6,12,7,3,5]<br><strong>输出</strong>：3<br><strong>解释</strong>：下面是形成 3 个分组的一种可行方法：<br>-&gt; 第 1 个分组的学生成绩为 grades &#x3D; [12] ，总成绩：12 ，学生数：1<br>-&gt; 第 2 个分组的学生成绩为 grades &#x3D; [6,7] ，总成绩：6 + 7 &#x3D; 13 ，学生数：2<br>-&gt; 第 3 个分组的学生成绩为 grades &#x3D; [10,3,5] ，总成绩：10 + 3 + 5 &#x3D; 18 ，学生数：3<br>可以证明无法形成超过 3 个分组。</p>
</blockquote>
<p>提示：<br>$1 \leq$ <code>grades.length</code> $\leq 10^{5}$<br>$1 \leq$ <code>grades[i]</code> $\leq 10^{5}$</p>
<blockquote>
<p>又是脑筋急转弯，大无语<br><strong>解题思路</strong>：<br>分组的形式可以是：将 <code>n</code> 个学生分成 <code>k</code> 组，每组人数为 <code>1、2、...、k</code>，若 $\frac{k \times (k+1)}{2} &lt; n$，即多出来 <code>m(&lt; k+1)</code> 个学生，则将多出来的学生随机分配到前面的组内。按成绩有序分组则可以满足总成绩递增的原则。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumGroups</span>(<span class="hljs-params">self, grades: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i * (i+<span class="hljs-number">1</span>) // <span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">len</span>(grades):<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> i-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="T3-6134-找到离给定两个节点最近的节点"><a href="#T3-6134-找到离给定两个节点最近的节点" class="headerlink" title="T3 6134. 找到离给定两个节点最近的节点"></a>T3 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-304/problems/find-closest-node-to-given-two-nodes/">6134. 找到离给定两个节点最近的节点</a></h2><p>给你一个 <code>n</code> 个节点的 <strong>有向图</strong> ，节点编号为 <code>0</code> 到 <code>n - 1</code> ，每个节点 <strong>至多</strong> 有一条出边。</p>
<p>有向图用大小为 <code>n</code> 下标从 <code>0</code> 开始的数组 <code>edges</code> 表示，表示节点 <code>i</code> 有一条有向边指向 <code>edges[i]</code> 。如果节点 <code>i</code> 没有出边，那么 <code>edges[i] == -1</code> 。</p>
<p>同时给你两个节点 <code>node1</code> 和 <code>node2</code> 。</p>
<p>请你返回一个从 <code>node1</code> 和 <code>node2</code> 都能到达节点的编号，使节点 <code>node1</code> 和节点 <code>node2</code> 到这个节点的距离 较大值最小化。如果有多个答案，请返回 <strong>最小</strong> 的节点编号。如果答案不存在，返回 <code>-1</code> 。</p>
<p>注意 <code>edges</code> 可能包含环。</p>
<blockquote>
<p><strong>输入</strong>：edges &#x3D; [2,2,3,-1], node1 &#x3D; 0, node2 &#x3D; 1<br><strong>输出</strong>：2<br><strong>解释</strong>：从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。<br>两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。<br><img src="https://s2.loli.net/2022/08/01/ouWwCn3yR51z4G8.png"></p>
</blockquote>
<p>提示：<br><code>n</code> &#x3D;&#x3D; <code>edges.length</code><br>$2 \leq$ <code>n</code> $\leq 10^{5}$<br>$-1 \leq$ <code>edges[i]</code> $&lt;$ <code>n</code><br><code>edges[i]</code> !&#x3D; <code>i</code><br>$0 \leq$ <code>node1</code>, <code>node2</code> $&lt;$ <code>n</code></p>
<blockquote>
<p><strong>解题思路</strong>：<br>从两个节点开始 <code>BFS</code>，记录到每个节点的距离，最后选择二者均能到达且距离最小的即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">closestMeetingNode</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], node1: <span class="hljs-built_in">int</span>, node2: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(edges)<br>        dst = [[-<span class="hljs-number">1</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        starts = [node1, node2]<br>        <br>        <span class="hljs-keyword">for</span> i, start <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(starts):<br>            dst[i][start] = <span class="hljs-number">0</span><br>            queue = [start]<br>            dist = <span class="hljs-number">1</span><br>            flag = [<span class="hljs-number">0</span>]*n<br>            <span class="hljs-keyword">while</span> queue:<br>                node = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> edges[node] &gt;= <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> dst[i][edges[node]] &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dist &lt; dst[i][edges[node]] <span class="hljs-keyword">or</span> dst[i][edges[node]] &lt; <span class="hljs-number">0</span>:<br>                        dst[i][edges[node]] = dist<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag[edges[node]]:<br>                        queue.append(edges[node])<br>                        flag[edges[node]] = <span class="hljs-number">1</span><br>                dist += <span class="hljs-number">1</span><br>        <br>        minD = inf<br>        retNode = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> dst[<span class="hljs-number">0</span>][i] &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> dst[<span class="hljs-number">1</span>][i] &gt;= <span class="hljs-number">0</span>:<br>                dst = <span class="hljs-built_in">max</span>(dst[<span class="hljs-number">0</span>][i], dst[<span class="hljs-number">1</span>][i])<br>                <span class="hljs-keyword">if</span> dst &lt; minD:<br>                    retNode = i<br>                    minD = dst<br>        <span class="hljs-keyword">return</span> retNode<br>                <br></code></pre></td></tr></table></figure>

<h2 id="T4-6135-图中的最长环"><a href="#T4-6135-图中的最长环" class="headerlink" title="T4 6135. 图中的最长环"></a>T4 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-304/problems/longest-cycle-in-a-graph/">6135. 图中的最长环</a></h2><p>给你一个 <code>n</code> 个节点的 <strong>有向图</strong> ，节点编号为 <code>0</code> 到 <code>n - 1</code> ，其中每个节点 <strong>至多</strong> 有一条出边。</p>
<p>图用一个大小为 <code>n</code> 下标从 <code>0</code> 开始的数组 <code>edges</code> 表示，节点 <code>i</code> 到节点 <code>edges[i]</code> 之间有一条有向边。如果节点 <code>i</code> 没有出边，那么 <code>edges[i] == -1</code> 。</p>
<p>请你返回图中的 <strong>最长</strong> 环，如果没有任何环，请返回 <code>-1</code> 。</p>
<p>一个环指的是起点和终点是 <strong>同一个</strong> 节点的路径。</p>
<blockquote>
<p><strong>输入</strong>：edges &#x3D; [3,3,4,2,3]<br><strong>输出</strong>：3<br><strong>解释</strong>：图中的最长环是：2 -&gt; 4 -&gt; 3 -&gt; 2 。<br>这个环的长度为 3 ，所以返回 3 。<br><img src="https://s2.loli.net/2022/08/01/mwDHV6cRz8EoiPa.png"></p>
</blockquote>
<p>提示：<br><code>n</code> &#x3D;&#x3D; <code>edges.length</code><br>$2 \leq$ <code>n</code> $\leq 10^{5}$<br>$-1 \leq$ <code>edges[i]</code> $&lt;$ <code>n</code><br><code>edges[i]</code> !&#x3D; <code>i</code></p>
<blockquote>
<p><strong>解题思路</strong>：<br>做完 <code>T3</code>，一种<strong>容易想到的思路</strong>是：从每个节点开始遍历整个有向图，若能到达自身节点则说明其处于环内，且距离为环的长度，遍历所有节点，更新最长环的长度即为答案。时间复杂度为 $O(N^{2}+N)$，超时无疑。<br><strong>优化思路</strong>：<br>通过<strong>拓扑排序</strong>依次<strong>去除入度为 <code>0</code> 的节点</strong>后，仅<strong>保留处于闭环内的节点</strong>，再通过上述方式遍历，且每个节点仅需访问一遍， 可将 <code>visit</code> 数组置于循环外。时间复杂度为 $O(N)$ 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestCycle</span>(<span class="hljs-params">self, edges: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(edges)<br>        inDegrees = [<span class="hljs-number">0</span>]*n   <span class="hljs-comment"># 入度</span><br>        ret = -<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-keyword">if</span> node &gt;= <span class="hljs-number">0</span>:<br>                inDegrees[node] += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 拓扑排序，依次去除入度为0的节点</span><br>        queue = [node <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inDegrees[node]]<br>        <span class="hljs-keyword">while</span> queue:<br>            node = queue.pop() <br>            dst_node = edges[node]<br>            <span class="hljs-keyword">if</span> dst_node &gt;= <span class="hljs-number">0</span>:<br>                inDegrees[dst_node] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inDegrees[dst_node]:<br>                    queue.append(dst_node)<br><br>        visit = [<span class="hljs-number">0</span>]*n<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inDegrees[i] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visit[i]:<br>                <span class="hljs-keyword">continue</span><br>            queue = [i]<br>            dist = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> queue:<br>                node = queue.pop() <span class="hljs-comment"># 注意这里用 pop()，pop(0) 复杂度为 O(N)，会超时                 </span><br>                <span class="hljs-keyword">if</span> edges[node] &gt;= <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visit[edges[node]]:      <span class="hljs-comment"># 未访问</span><br>                        queue.append(edges[node])<br>                        visit[edges[node]] = <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:                           <span class="hljs-comment"># 已访问，闭环结束，更新最长环</span><br>                        <span class="hljs-keyword">if</span> dist &gt; ret:<br>                            ret = dist<br>                dist += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="2022-07-24-第-303-场周赛"><a href="#2022-07-24-第-303-场周赛" class="headerlink" title="2022-07-24 第 303 场周赛"></a>2022-07-24 第 303 场周赛</h1><h2 id="T1-6124-第一个出现两次的字母"><a href="#T1-6124-第一个出现两次的字母" class="headerlink" title="T1 6124. 第一个出现两次的字母"></a>T1 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-303/problems/first-letter-to-appear-twice/">6124. 第一个出现两次的字母</a></h2><p>给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>如果 a 的 第二次 出现比 b 的 第二次 出现在字符串中的位置更靠前，则认为字母 a 在字母 b 之前出现两次。</li>
<li>s 包含至少一个出现两次的字母。</li>
</ul>
<blockquote>
<p><strong>输入</strong>：s &#x3D; “abccbaacz”<br><strong>输出</strong>：”c”<br><strong>解释</strong>：<br>字母 ‘a’ 在下标 0 、5 和 6 处出现。<br>字母 ‘b’ 在下标 1 和 4 处出现。<br>字母 ‘c’ 在下标 2 、3 和 7 处出现。<br>字母 ‘z’ 在下标 8 处出现。<br>字母 ‘c’ 是第一个出现两次的字母，因为在所有字母中，’c’ 第二次出现的下标是最小的。</p>
</blockquote>
<p>提示：<br>$2 \leq$ <code>s.length</code> $\leq 100$<br><code>s</code> 由小写英文字母组成<br><code>s</code> 包含至少一个重复字母</p>
<blockquote>
<p><strong>解题思路</strong>：<br>哈希表＋模拟</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repeatedCharacter</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        hashmap = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            t = <span class="hljs-built_in">ord</span>(s[i])-<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>            hashmap[t] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> hashmap[t] == <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> s[i]<br></code></pre></td></tr></table></figure>

<h2 id="T2-6125-相等行列对"><a href="#T2-6125-相等行列对" class="headerlink" title="T2 6125. 相等行列对"></a>T2 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-303/problems/equal-row-and-column-pairs/">6125. 相等行列对</a></h2><p>给你一个下标从 <code>0</code> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code> 列相等的行列对 <code>(Ri, Cj)</code> 的数目。</p>
<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>
<blockquote>
<p><strong>输入</strong>：grid &#x3D; [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]<br><strong>输出</strong>：3<br><strong>解释</strong>：存在三对相等行列对：<br>-&gt; (第 0 行，第 0 列)：[3,1,2,2]<br>-&gt; (第 2 行, 第 2 列)：[2,4,2,2]<br>-&gt; (第 3 行, 第 2 列)：[2,4,2,2]<br><img src="https://s2.loli.net/2022/07/24/DOSv9eRTg2JaFXt.jpg" width=128 height=128 left=0/></p>
</blockquote>
<p>提示：<br><code>n</code> &#x3D;&#x3D; <code>grid.length</code> &#x3D;&#x3D; <code>grid[i].length</code><br>$1 \leq$ <code>n</code> $\leq 200$<br>$1 \leq$ <code>grid[i][j]</code> $\leq 10^{5}$</p>
<blockquote>
<p><strong>解题思路</strong>：<br>暴力即可，对比每一行和每一列</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">equalPairs</span>(<span class="hljs-params">self, grid: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> grid[i] == [grid[k][j] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]:<br>                    ret += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>

<h2 id="T3-6126-设计食物评分系统"><a href="#T3-6126-设计食物评分系统" class="headerlink" title="T3 6126. 设计食物评分系统"></a>T3 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-303/problems/design-a-food-rating-system/">6126. 设计食物评分系统</a></h2><p>设计一个支持下述操作的食物评分系统：</p>
<p>修改 系统中列出的某种食物的评分。<br>返回系统中某一类烹饪方式下评分最高的食物。<br>实现 <code>FoodRatings</code> 类：</p>
<ul>
<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> 初始化系统。食物由 <code>foods</code>、<code>cuisines</code> 和 <code>ratings</code> 描述，长度均为 <code>n</code> 。</li>
<li><code>foods[i]</code> 是第 <code>i</code> 种食物的名字。</li>
<li><code>cuisines[i]</code> 是第 <code>i</code> 种食物的烹饪方式。</li>
<li><code>ratings[i]</code> 是第 <code>i</code> 种食物的最初评分。</li>
<li><code>void changeRating(String food, int newRating)</code> 修改名字为 <code>food</code> 的食物的评分。</li>
<li><code>String highestRated(String cuisine)</code> 返回指定烹饪方式 <code>cuisine</code> 下评分最高的食物的名字。如果存在并列，返回 <strong>字典序较小</strong> 的名字。<br><strong>注意</strong>：字符串 <code>x</code> 的字典序比字符串 <code>y</code> 更小的前提是：<code>x</code> 在字典中出现的位置在 <code>y</code> 之前，也就是说，要么 <code>x</code> 是 <code>y</code> 的前缀，或者在满足 <code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 处，<code>x[i]</code> 在字母表中出现的位置在 <code>y[i]</code> 之前。</li>
</ul>
<blockquote>
<p><strong>输入</strong>:<br>[“FoodRatings”, “highestRated”, “highestRated”, “changeRating”, “highestRated”, “changeRating”, “highestRated”]<br>[[[“kimchi”, “miso”, “sushi”, “moussaka”, “ramen”, “bulgogi”], [“korean”, “japanese”, “japanese”, “greek”, “japanese”, “korean”], [9, 12, 8, 15, 14, 7]], [“korean”], [“japanese”], [“sushi”, 16], [“japanese”], [“ramen”, 16], [“japanese”]]<br><strong>输出</strong>:<br>[null, “kimchi”, “ramen”, null, “sushi”, null, “ramen”]<br><strong>解释</strong>:<br>FoodRatings foodRatings &#x3D; new FoodRatings([“kimchi”, “miso”, “sushi”, “moussaka”, “ramen”, “bulgogi”], [“korean”, “japanese”, “japanese”, “greek”, “japanese”, “korean”], [9, 12, 8, 15, 14, 7]);<br>foodRatings.highestRated(“korean”); &#x2F;&#x2F; 返回 “kimchi”，kimchi” 是分数最高的韩式料理，评分为 9 。<br>foodRatings.highestRated(“japanese”); &#x2F;&#x2F; 返回 “ramen”，”ramen” 是分数最高的日式料理，评分为 14 。<br>foodRatings.changeRating(“sushi”, 16); &#x2F;&#x2F; “sushi” 现在评分变更为 16 。<br>foodRatings.highestRated(“japanese”); &#x2F;&#x2F; 返回 “sushi”，”sushi” 是分数最高的日式料理，评分为 16 。<br>foodRatings.changeRating(“ramen”, 16); &#x2F;&#x2F; “ramen” 现在评分变更为 16 。<br>foodRatings.highestRated(“japanese”); &#x2F;&#x2F; 返回 “ramen”，”sushi” 和 “ramen” 的评分都是 16，但是，”ramen” 的字典序比 “sushi” 更小。</p>
</blockquote>
<p>提示：<br>$1 \leq$ <code>n</code> $\leq 2 * 10^{4}$<br><code>n</code> &#x3D;&#x3D; <code>foods.length</code> &#x3D;&#x3D; <code>cuisines.length</code> &#x3D;&#x3D; <code>ratings.length</code><br>$1 \leq$ <code>foods[i].length, cuisines[i].length</code> $\leq 10$<br><code>foods[i]、cuisines[i]</code> 由小写英文字母组成<br>$1 \leq$ <code>ratings[i]</code> $\leq 10^{8}$<br><code>foods</code> 中的所有字符串 <strong>互不相同</strong><br>在对 <code>changeRating</code> 的所有调用中，<code>food</code> 是系统中食物的名字。<br>在对 <code>highestRated</code> 的所有调用中，<code>cuisine</code> 是系统中 <strong>至少一种</strong> 食物的烹饪方式。<br>最多调用 <code>changeRating</code> 和 <code>highestRated</code> 总计 $2 * 10^{4}$ 次</p>
<blockquote>
<p><strong>解题思路</strong>：<br>建立映射： 将 <code>food[i]</code> 的烹饪方式 <code>cuisines[i]</code> 和 最初评分 <code>ratings[i]</code> 存入一个字典中。将 <code>cuisines[i]</code> 的下所有食物和最初评分存入一个字典中，并按照评分排序。<br><strong>实现方式</strong>：<br>利用 <code>defaultdict</code> 建立字典，相比于 <code>dict</code>，其可以避免字典中 <code>key</code> 值不存在时的 <code>KeyError</code> 异常，<code>SortedList</code> 用于评分排序，其插入元素的时间复杂度为 $O(logn)$<br><strong><code>Dict + SortedList</code> 可以解决所有这类问题</strong></p>
</blockquote>
<blockquote>
<p><code>defaultdict</code> 使用详解：<code>defaultdict</code> 在初始化时可以提供一个 <code>default_factory</code> 的参数，<code>default_factory</code> 接收一个工厂函数作为参数， 可以是 <code>int</code>、<code>str</code>、<code>list</code> 等内置函数，也可以是 <strong>自定义函数</strong>。其他方法与 <code>dict</code> 一致。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FoodRatings</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, foods: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], cuisines: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], ratings: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>        self.food_cuisine = defaultdict(<span class="hljs-built_in">str</span>)<br>        self.food_rating = defaultdict(<span class="hljs-built_in">int</span>)<br>        self.cuisine = defaultdict(<span class="hljs-keyword">lambda</span>: SortedList(key=<span class="hljs-keyword">lambda</span> x: (-x[<span class="hljs-number">1</span>], x[<span class="hljs-number">0</span>])))<br>        n = <span class="hljs-built_in">len</span>(foods)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            self.food_cuisine[foods[i]] = cuisines[i]              <span class="hljs-comment"># food -&gt; cuisine</span><br>            self.food_rating[foods[i]] = ratings[i]                <span class="hljs-comment"># food -&gt; rating</span><br>            self.cuisine[cuisines[i]].add([foods[i], ratings[i]])  <span class="hljs-comment"># cuisine -&gt; [food, rating]</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">changeRating</span>(<span class="hljs-params">self, food: <span class="hljs-built_in">str</span>, newRating: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        cuisine = self.food_cuisine[food]<br>        rating = self.food_rating[food]<br>        self.cuisine[cuisine].discard([food, rating])   <span class="hljs-comment"># 删除已有评分记录，这里用 discard 以防报错</span><br>        self.food_rating[food] = newRating              <span class="hljs-comment"># 更新 food -&gt; rating</span><br>        self.cuisine[cuisine].add([food, newRating])    <span class="hljs-comment"># 添加评分记录 cuisine -&gt; [food, rating]</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">highestRated</span>(<span class="hljs-params">self, cuisine: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># 设定了按评分的负值排序，当最大评分有多个 food 时，字典序更小的会在前</span><br>        <span class="hljs-keyword">return</span> self.cuisine[cuisine][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br><br><span class="hljs-comment"># Your FoodRatings object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = FoodRatings(foods, cuisines, ratings)</span><br><span class="hljs-comment"># obj.changeRating(food,newRating)</span><br><span class="hljs-comment"># param_2 = obj.highestRated(cuisine)</span><br></code></pre></td></tr></table></figure>


<h2 id="T4-6127-优质数对的数目"><a href="#T4-6127-优质数对的数目" class="headerlink" title="T4 6127. 优质数对的数目"></a>T4 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-303/problems/number-of-excellent-pairs/">6127. 优质数对的数目</a></h2><p>给你一个下标从 <code>0</code> 开始的正整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>
<p>如果满足下述条件，则数对 <code>(num1, num2)</code> 是 <strong>优质数对</strong> ：</p>
<ul>
<li><code>num1</code> 和 <code>num2</code> <strong>都</strong> 在数组 <code>nums</code> 中存在。</li>
<li><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的二进制表示中值为 <code>1</code> 的位数之和大于等于 <code>k</code> ，其中 <code>OR</code> 是按位 <strong>或</strong> 操作，而 <code>AND</code> 是按位 <strong>与</strong> 操作。<br>返回 <strong>不同</strong> 优质数对的数目。</li>
</ul>
<p>如果 <code>a != c</code> 或者 <code>b != d</code> ，则认为 <code>(a, b)</code> 和 <code>(c, d)</code> 是不同的两个数对。例如，<code>(1, 2)</code> 和 <code>(2, 1)</code> 不同。</p>
<p><strong>注意</strong>：如果 <code>num1</code> 在数组中至少出现 <strong>一次</strong> ，则满足 <code>num1 == num2</code> 的数对 <code>(num1, num2)</code> 也可以是优质数对。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [1,2,3,1], k &#x3D; 3<br><strong>输出</strong>：5<br><strong>解释</strong>：有如下几个优质数对：<br>-&gt; (3, 3)：(3 AND 3) 和 (3 OR 3) 的二进制表示都等于 (11) 。值为 1 的位数和等于 2 + 2 &#x3D; 4 ，大于等于 k &#x3D; 3 。<br>-&gt; (2, 3) 和 (3, 2)： (2 AND 3) 的二进制表示等于 (10) ，(2 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 &#x3D; 3 。<br>-&gt; (1, 3) 和 (3, 1)： (1 AND 3) 的二进制表示等于 (01) ，(1 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 &#x3D; 3 。<br>所以优质数对的数目是 5 。</p>
</blockquote>
<p>提示：<br>$1 \leq$ <code>nums.length</code> $\leq 10^{5}$<br>$1 \leq$ <code>nums[i]</code> $\leq 10^{9}$<br>$1 \leq$ <code>k</code> $\leq 60$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countExcellentPairs</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums))<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        bits = []<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            bit = self.helper(nums[i])<br>            <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>*bit &gt;= k:<br>                ret += <span class="hljs-number">1</span><br>            bits.append([nums[i], bit])<br><br>        bits.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<br>        left, right = <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            <span class="hljs-keyword">if</span> bits[left][<span class="hljs-number">1</span>] + bits[right][<span class="hljs-number">1</span>] &gt;= k:<br>                ret += (right-left)*<span class="hljs-number">2</span><br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ret<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">self, n</span>):<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>                ret += <span class="hljs-number">1</span><br>            n = n//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>


<hr>
<h1 id="2022-07-23-第-83-场双周赛"><a href="#2022-07-23-第-83-场双周赛" class="headerlink" title="2022-07-23 第 83 场双周赛"></a>2022-07-23 第 83 场双周赛</h1><h2 id="T1-6128-最好的扑克手牌"><a href="#T1-6128-最好的扑克手牌" class="headerlink" title="T1 6128. 最好的扑克手牌"></a>T1 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-83/problems/best-poker-hand/">6128. 最好的扑克手牌</a></h2><p>给你一个整数数组 <code>ranks</code> 和一个字符数组 <code>suit</code> 。你有 <code>5</code> 张扑克牌，第 <code>i</code> 张牌大小为 <code>ranks[i]</code> ，花色为 <code>suits[i]</code> 。</p>
<p>下述是从好到坏你可能持有的 <strong>手牌类型</strong> ：</p>
<p>1、<code>&quot;Flush&quot;</code>：同花，五张相同花色的扑克牌。<br>2、<code>&quot;Three of a Kind&quot;</code>：三条，有 <code>3</code> 张大小相同的扑克牌。<br>3、<code>&quot;Pair&quot;</code>：对子，两张大小一样的扑克牌。<br>4、<code>&quot;High Card&quot;</code>：高牌，五张大小互不相同的扑克牌。<br>请你返回一个字符串，表示给定的 <code>5</code> 张牌中，你能组成的 <strong>最好手牌类型</strong> 。</p>
<p><strong>注意</strong>：返回的字符串 大小写 需与题目描述相同。</p>
<blockquote>
<p><strong>输入</strong>：ranks &#x3D; [4,4,2,4,4], suits &#x3D; [“d”,”a”,”a”,”b”,”c”]<br><strong>输出</strong>：”Three of a Kind”<br><strong>解释</strong>：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 “Three of a Kind” 。<br>注意我们也可以得到 “Pair” ，但是 “Three of a Kind” 是更好的手牌类型。<br>有其他的 3 张牌也可以组成 “Three of a Kind” 手牌类型。</p>
</blockquote>
<p>提示：<br><code>ranks.length</code> &#x3D;&#x3D; <code>suits.length</code> &#x3D;&#x3D; 5<br>1 $\leq$ <code>ranks[i]</code> $\leq$ 13<br>‘a’ $\leq$ <code>suits[i]</code> $\leq$  ‘d’<br>任意两张扑克牌不会同时有相同的大小和花色。</p>
<blockquote>
<p><strong>解题思路</strong>：<br>直接模拟即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bestHand</span>(<span class="hljs-params">self, ranks: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], suits: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(suits)) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Flush&quot;</span><br>        ranks.sort()<br>        ranks_set = <span class="hljs-built_in">set</span>(ranks)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ranks_set) &lt;= <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">if</span> ranks.count(ranks[<span class="hljs-number">2</span>]) &gt;= <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Three of a Kind&quot;</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pair&quot;</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(ranks_set) == <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pair&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;High Card&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="T2-6129-全-0-子数组的数目"><a href="#T2-6129-全-0-子数组的数目" class="headerlink" title="T2 6129. 全 0 子数组的数目"></a>T2 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-83/problems/number-of-zero-filled-subarrays/">6129. 全 0 子数组的数目</a></h2><p>给你一个整数数组 <code>nums</code> ，返回全部为 <code>0</code> 的 <strong>子数组</strong> 数目。</p>
<p><strong>子数组</strong> 是一个数组中一段连续非空元素组成的序列。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [0,0,0,2,0,0]<br><strong>输出</strong>：9<br><strong>解释</strong>：<br>子数组 [0] 出现了 5 次。<br>子数组 [0,0] 出现了 3 次。<br>子数组 [0,0,0] 出现了 1 次。<br>不存在长度大于 3 的全 0 子数组，所以我们返回 9 。</p>
</blockquote>
<p>提示：<br>$1 \leq$ <code>nums.length</code> $\leq 10^{5}$<br>$-10^{9} \leq$ <code>nums[i]</code> $\leq 10^{9}$</p>
<blockquote>
<p><strong>解题思路</strong>：<br><strong>数学题</strong>：记录连续的 <code>0</code> 的个数，然后对于每个连续长度为 <code>n</code> 的 <code>0</code> 序列，其中包含了长度 <code>n-k+1</code> 个为 <code>k</code> 的 <code>0</code> 序列，（如一个长度为 <code>3</code> 的 <code>0</code> 序列，其包含了 <code>3</code> 个长度为 <code>1</code>，<code>2</code> 个长度为 <code>2</code>，<code>1</code> 个长度为 <code>3</code> 的 <code>0</code> 序列）。易知，长度为 <code>n</code> 的 <code>0</code> 序列包含了 $\sum_{i&#x3D;1}^{n}i$ 个全 <code>0</code> 子数组。对每个 <code>0</code> 序列的长度计算以上值累加即为答案。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">zeroFilledSubarray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        cnt = <span class="hljs-number">0</span><br>        temp = []<br>        ret = <span class="hljs-number">0</span><br>        nums.append(-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span>:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[i] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> cnt &gt; <span class="hljs-number">0</span>:<br>                temp.append(cnt)<br>                cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> temp:<br>            ret += t*(t+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>


<h2 id="T3-6130-设计数字容器系统"><a href="#T3-6130-设计数字容器系统" class="headerlink" title="T3 6130. 设计数字容器系统"></a>T3 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-83/problems/design-a-number-container-system/">6130. 设计数字容器系统</a></h2><p>设计一个数字容器系统，可以实现以下功能：</p>
<p>在系统中给定下标处 <strong>插入</strong> 或者 <strong>替换</strong> 一个数字。<br><strong>返回</strong> 系统中给定数字的最小下标。<br>请你实现一个 <code>NumberContainers</code> 类：</p>
<p><code>NumberContainers()</code> 初始化数字容器系统。<br><code>void change(int index, int number)</code> 在下标 <code>index</code> 处填入 <code>number</code> 。如果该下标 <code>index</code> 处已经有数字了，那么用 <code>number</code> 替换该数字。<br><code>int find(int number)</code> 返回给定数字 <code>number</code> 在系统中的最小下标。如果系统中没有 <code>number</code> ，那么返回 <code>-1</code> 。</p>
<blockquote>
<p><strong>输入</strong>：<br>[“NumberContainers”, “find”, “change”, “change”, “change”, “change”, “find”, “change”, “find”]<br>[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]<br><strong>输出</strong>：<br>[null, -1, null, null, null, null, 1, null, 2]<br><strong>解释</strong>：<br>NumberContainers nc &#x3D; new NumberContainers();<br>nc.find(10); &#x2F;&#x2F; 没有数字 10 ，所以返回 -1 。<br>nc.change(2, 10); &#x2F;&#x2F; 容器中下标为 2 处填入数字 10 。<br>nc.change(1, 10); &#x2F;&#x2F; 容器中下标为 1 处填入数字 10 。<br>nc.change(3, 10); &#x2F;&#x2F; 容器中下标为 3 处填入数字 10 。<br>nc.change(5, 10); &#x2F;&#x2F; 容器中下标为 5 处填入数字 10 。<br>nc.find(10); &#x2F;&#x2F; 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。<br>nc.change(1, 20); &#x2F;&#x2F; 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。<br>nc.find(10); &#x2F;&#x2F; 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。 </p>
</blockquote>
<p>提示：<br>$1 \leq$ <code>index, number</code> $\leq 10^{9}$<br>调用 <code>change</code> 和 <code>find</code> 的 <strong>总次数</strong> 不超过 $10^{5}$ 次。</p>
<blockquote>
<p><code>Python</code> 数据结构还是掌握得不够，<code>Sortedlist</code> 居然不会用。除以下特殊方法外，其他方法与列表基本一致。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br>sl = SortedList([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>])<br><span class="hljs-comment"># 添加元素</span><br>sl.add(<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br><span class="hljs-comment">#删除元素 </span><br>sl.remove(<span class="hljs-number">4</span>) <span class="hljs-comment"># 元素不存在时会报错</span><br>sl.discard(<span class="hljs-number">4</span>) <span class="hljs-comment"># 元素不存在时不会报错</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]<br><span class="hljs-comment"># 查找元素</span><br>pos = test_sl.bisect_left(<span class="hljs-number">2</span>) <span class="hljs-comment"># 查找元素存在的位置</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberContainers</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.indexes = &#123;&#125;<br>        self.<span class="hljs-built_in">list</span> = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> index <span class="hljs-keyword">in</span> self.<span class="hljs-built_in">list</span>:<br>            self.indexes[self.<span class="hljs-built_in">list</span>[index]].remove(index)<br>        <span class="hljs-keyword">if</span> number <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.indexes:<br>            self.indexes[number] = SortedList()<br>        self.indexes[number].add(index)<br>        self.<span class="hljs-built_in">list</span>[index] = number<br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> number <span class="hljs-keyword">in</span> self.indexes <span class="hljs-keyword">and</span> self.indexes[number]:<br>            <span class="hljs-comment"># print(self.list, self.indexes)</span><br>            <span class="hljs-keyword">return</span> self.indexes[number][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <br><span class="hljs-comment"># Your NumberContainers object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = NumberContainers()</span><br><span class="hljs-comment"># obj.change(index,number)</span><br><span class="hljs-comment"># param_2 = obj.find(number)</span><br></code></pre></td></tr></table></figure>

<h2 id="T4-6131-不可能得到的最短骰子序列"><a href="#T4-6131-不可能得到的最短骰子序列" class="headerlink" title="T4 6131. 不可能得到的最短骰子序列"></a>T4 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-83/problems/shortest-impossible-sequence-of-rolls/">6131. 不可能得到的最短骰子序列</a></h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>rolls</code> 和一个整数 <code>k</code> 。你扔一个 <code>k</code> 面的骰子 <code>n</code> 次，骰子的每个面分别是 <code>1</code> 到 <code>k</code> ，其中第 <code>i</code> 次扔得到的数字是 <code>rolls[i]</code> 。</p>
<p>请你返回 <strong>无法</strong> 从 <code>rolls</code> 中得到的 <strong>最短</strong> 骰子子序列的长度。</p>
<p>扔一个 <code>k</code> 面的骰子 <code>len</code> 次得到的是一个长度为 <code>len</code> 的 <strong>骰子子序列</strong> 。</p>
<p>注意 ，子序列只需要保持在原数组中的顺序，不需要连续。</p>
<blockquote>
<p><strong>输入</strong>：rolls &#x3D; [4,2,1,2,3,3,2,4,1], k &#x3D; 4<br><strong>输出</strong>：3<br><strong>解释</strong>：所有长度为 1 的骰子子序列 [1] ，[2] ，[3] ，[4] 都可以从原数组中得到。<br>所有长度为 2 的骰子子序列 [1, 1] ，[1, 2] ，… ，[4, 4] 都可以从原数组中得到。<br>子序列 [1, 4, 2] 无法从原数组中得到，所以我们返回 3 。<br>还有别的子序列也无法从原数组中得到。</p>
</blockquote>
<p>提示：<br><code>n</code> &#x3D;&#x3D; <code>rolls.length</code><br>$1 \leq$ <code>n</code> $\leq 10^{5}$<br>$1 \leq$ <code>rolls[i]</code> $\leq$ <code>k</code> $\leq 10^{5}$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br></code></pre></td></tr></table></figure>


<hr>
<h1 id="2022-07-17-第-302-场周赛"><a href="#2022-07-17-第-302-场周赛" class="headerlink" title="2022-07-17 第 302 场周赛"></a>2022-07-17 第 302 场周赛</h1><h2 id="T1-6120-数组能形成多少数对"><a href="#T1-6120-数组能形成多少数对" class="headerlink" title="T1 6120. 数组能形成多少数对"></a>T1 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-302/problems/maximum-number-of-pairs-in-array/">6120. 数组能形成多少数对</a></h2><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p>
<p>从 <code>nums</code> 选出 <strong>两个 相等的</strong> 整数<br>从 <code>nums</code> 中移除这两个整数，形成一个 数对<br>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</p>
<p>返回一个下标从 <code>0</code> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中 <code>answer[0]</code> 是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [1,3,2,1,3,2,2]<br><strong>输出</strong>：[3,1]<br><strong>解释</strong>：<br>nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums &#x3D; [3,2,3,2,2] 。<br>nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums &#x3D; [2,2,2] 。<br>nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums &#x3D; [2] 。<br>无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。</p>
</blockquote>
<p><strong>提示</strong>：<br>$1 \leq nums.length \leq 100$<br>$1 \leq nums[i] \leq 100$</p>
<blockquote>
<p>愉快的签到题~一上来肾上腺素飙升，WA了两发（🙂🙂🙂</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfPairs</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        hashmap = [<span class="hljs-number">0</span>]*<span class="hljs-number">101</span><br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            hashmap[nums[i]] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>):<br>            ret += hashmap[i]//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> [ret, n-<span class="hljs-number">2</span>*ret]<br></code></pre></td></tr></table></figure>

<h2 id="T2-6164-数位和相等数对的最大和"><a href="#T2-6164-数位和相等数对的最大和" class="headerlink" title="T2 6164. 数位和相等数对的最大和"></a>T2 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-302/problems/max-sum-of-a-pair-with-equal-sum-of-digits/">6164. 数位和相等数对的最大和</a></h2><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，数组中的元素都是 <strong>正</strong> 整数。请你选出两个下标 <code>i</code> 和 <code>j</code>（<code>i != j</code>），且 <code>nums[i]</code> 的数位和与  <code>nums[j]</code> 的数位和相等。</p>
<p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回 <code>nums[i] + nums[j]</code> 可以得到的 <strong>最大值</strong> 。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [18,43,36,13,7]<br><strong>输出</strong>：54<br><strong>解释</strong>：满足条件的数对 (i, j) 为：<br>-&gt; (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 &#x3D; 54 。<br>-&gt; (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 &#x3D; 50 。<br>所以可以获得的最大和是 54 。</p>
</blockquote>
<p><strong>提示</strong>：<br>$1 \leq nums.length \leq 10^{5}$<br>$1 \leq nums[i] \leq 10^{9}$</p>
<blockquote>
<p>看了眼数据量，最大和值为 <code>9×9=81</code>，直接哈希表记录，<code>haspmap[i]</code> 为数位和为 <code>i</code> 的整数列表，返回列表长度大于 <code>2</code> 且列表中最大的两个元素之和，遍历 <code>hashmap</code> 更新结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        hashmap = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">82</span>)]<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            hashmap[self.helper(nums[i])].append(nums[i])<br>        ret = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(hashmap)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(hashmap[i]) &gt;= <span class="hljs-number">2</span>:<br>                hashmap[i].sort()<br>                <span class="hljs-keyword">if</span> ret &lt; hashmap[i][-<span class="hljs-number">1</span>] + hashmap[i][-<span class="hljs-number">2</span>]:<br>                    ret = hashmap[i][-<span class="hljs-number">1</span>] + hashmap[i][-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> ret<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">self, n</span>):<br>        ret = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>            ret += n%<span class="hljs-number">10</span><br>            n = n//<span class="hljs-number">10</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>

<h2 id="T3-6121-裁剪数字后查询第-K-小的数字"><a href="#T3-6121-裁剪数字后查询第-K-小的数字" class="headerlink" title="T3 6121. 裁剪数字后查询第 K 小的数字"></a>T3 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-302/problems/query-kth-smallest-trimmed-number/">6121. 裁剪数字后查询第 K 小的数字</a></h2><p>给你一个下标从 <code>0</code> 开始的字符串数组 <code>nums</code> ，其中每个字符串 <strong>长度相等</strong> 且只包含数字。</p>
<p>再给你一个下标从 <code>0</code> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [ki, trimi]</code> 。对于每个 <code>queries[i]</code> ，你需要：</p>
<p>将 <code>nums</code> 中每个数字 <strong>裁剪</strong> 到剩下 <strong>最右边</strong> <code>trimi</code> 个数位。<br>在裁剪过后的数字中，找到 <code>nums</code> 中第 <code>ki</code> 小数字对应的 <strong>下标</strong> 。如果两个裁剪后数字一样大，那么下标 <strong>更小</strong> 的数字视为更小的数字。<br>将 <code>nums</code> 中每个数字恢复到原本字符串。<br>请你返回一个长度与 <code>queries</code> 相等的数组 <code>answer</code>，其中 <code>answer[i]</code> 是第 <code>i</code> 次查询的结果。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [“102”,”473”,”251”,”814”], queries &#x3D; [[1,1],[2,3],[4,2],[1,2]]<br><strong>输出</strong>：[2,2,1,0]<br><strong>解释</strong>：<br>查询 1. 裁剪到只剩 1 个数位后，nums &#x3D; [“2”,”3”,”1”,”4”] 。最小的数字是 1 ，下标为 2 。<br>查询 2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。<br>查询 3. 裁剪到剩 2 个数位后，nums &#x3D; [“02”,”73”,”51”,”14”] 。第 4 小的数字是 73 ，下标为 1 。<br>查询 4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。<br>   注意，裁剪后数字 “02” 值为 2 。</p>
</blockquote>
<p><strong>提示</strong>：<br>裁剪到剩下 <code>x</code> 个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code> 个数位。<br><code>nums</code> 中的字符串可能会有前导 <code>0</code> 。<br>$1 \leq nums.length \leq 100$<br>$1 \leq nums[i].length \leq 100$<br><code>nums[i]</code> 只包含数字。<br>所有 <code>nums[i].length</code> 的长度 相同 。<br>$1 \leq queries.length \leq 100$<br>$queries[i].length &#x3D;&#x3D; 2$<br>$1 \leq k_{i} \leq nums.length$<br>$1 \leq trim_{i} \leq nums[0].length$</p>
<blockquote>
<p>这题和第四题换一下位置还行，这点数据量，写半天超时，找不到哪里出了死循环……儒哥更惨 👇👇👇</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/07/17/fTxAbjd1YGFVuRB.png"></p>
<blockquote>
<p><code>TLE</code> 的代码 👇👇👇</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestTrimmedNumbers</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums[<span class="hljs-number">0</span>])<br>        ret = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>            nums_ = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>                temp = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(queries[i][<span class="hljs-number">1</span>]):<br>                    temp += <span class="hljs-built_in">int</span>(<span class="hljs-built_in">ord</span>(nums[j][n-k-<span class="hljs-number">1</span>])-<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>))*<span class="hljs-number">10</span>**k<br>                nums_.append([j, temp])<br>            nums_.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>            ret.append(nums_[queries[i][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>            <br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>
<blockquote>
<p>赛后，看了眼大家的写法，才意识到<strong>字符串可以直接排序</strong>，不一定非要转换成整数，字符串转化成整数的过程嵌套在双层循环中，时间复杂度爆炸。<br>以下为 <code>AC</code> 的代码 👇👇👇</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestTrimmedNumbers</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], queries: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        n = <span class="hljs-built_in">len</span>(nums[<span class="hljs-number">0</span>])<br>        ret = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>            nums_ = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>                nums_.append([j, nums[j][-queries[i][<span class="hljs-number">1</span>]:]])  <span class="hljs-comment"># 上面的四行改成这一行</span><br>            nums_.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>            ret.append(nums_[queries[i][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>                <br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>

<h2 id="T4-6122-使数组可以被整除的最少删除次数"><a href="#T4-6122-使数组可以被整除的最少删除次数" class="headerlink" title="T4 6122. 使数组可以被整除的最少删除次数"></a>T4 <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-302/problems/minimum-deletions-to-make-array-divisible/">6122. 使数组可以被整除的最少删除次数</a></h2><p>给你两个正整数数组 <code>nums</code> 和 <code>numsDivide</code> 。你可以从 <code>nums</code> 中删除任意数目的元素。</p>
<p>请你返回使 <code>nums</code> 中 <strong>最小</strong> 元素可以整除 <code>numsDivide</code> 中所有元素的 <strong>最少</strong> 删除次数。如果无法得到这样的元素，返回 <code>-1</code> 。</p>
<p>如果 <code>y % x == 0</code> ，那么我们说整数 <code>x</code> 整除 <code>y</code> 。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [2,3,2,4,3], numsDivide &#x3D; [9,6,9,3,15]<br><strong>输出</strong>：2<br><strong>解释</strong>：<br>[2,3,2,4,3] 中最小元素是 2 ，它无法整除 numsDivide 中所有元素。<br>我们从 nums 中删除 2 个大小为 2 的元素，得到 nums &#x3D; [3,4,3] 。<br>[3,4,3] 中最小元素为 3 ，它可以整除 numsDivide 中所有元素。<br>可以证明 2 是最少删除次数。</p>
</blockquote>
<p><strong>提示</strong>：<br>$1 \leq nums.length, numsDivide.length \leq 10^{5}$<br>$1 \leq nums[i], numsDivide[i] \leq 10^{9}$</p>
<blockquote>
<p><code>Hard</code>……<br>问题等价于求在有序的 <code>nums</code> 中，能够被 <code>numsDivide</code> 中所有元素的最大公约数整除的最小元素的位置索引</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minOperations</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], numsDivide: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        factor = numsDivide[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(numsDivide)):<br>            factor = gcd(factor, numsDivide[i])<br>        nums.sort()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> factor % nums[i] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="2022-07-13-蔚来-2023-届提前批笔试"><a href="#2022-07-13-蔚来-2023-届提前批笔试" class="headerlink" title="2022-07-13 蔚来 2023 届提前批笔试"></a>2022-07-13 蔚来 2023 届提前批笔试</h1><h2 id="T2-最少的操作次数"><a href="#T2-最少的操作次数" class="headerlink" title="T2 最少的操作次数"></a>T2 最少的操作次数</h2><p>小红可以对一个数进行如下两种操作：将这个数乘以 $x$，或将这个数乘以 $y$。操作次数是没有限制的。小红想知道，自己最少经过多少次操作以后，可以把 $a$ 变成 $b$ ？</p>
<blockquote>
<p><strong>输入描述</strong>：<br>四个正整数 $x, y, a, b$，用空格隔开。<br>$2 \leq x, y \leq 100$<br>$1 \leq a, b \leq 10^{9}$<br><strong>输出描述</strong>：<br>如果小红无论如何都无法把 $a$ 变成 $b$，则输出 $-1$。否则输出小红操作的最少次数，可以证明，如果存在某种操作，那么最少次数一定是固定的。</p>
</blockquote>
<blockquote>
<p><strong>示例输入</strong>：<br>2 3 5 20<br><strong>示例输出</strong>：<br>2<br><strong>解释</strong>：<br>x &#x3D; 2，y &#x3D; 3，进行两次乘 2 操作，可以把 5 变成 20。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br></code></pre></td></tr></table></figure>

<h2 id="T3-牛牛的开心旅行"><a href="#T3-牛牛的开心旅行" class="headerlink" title="T3 牛牛的开心旅行"></a>T3 牛牛的开心旅行</h2><p>牛牛对 $n$ 个城市的旅游情况进行了规划。<br>已知每个城市有两种属性 $x_{i}$ 和 $y_{i}$，其中 $x_{i}$ 表示去第 $i$ 号城市的花费，$y_{i}$ 表示在第 $i$ 号城市游玩后会得到的开心值。<br>现在牛牛希望从中挑选一些城市去游玩，但挑选出的城市必须满足任意两个城市之间花费的绝对值小于 $k$。<br>他想请你帮他计算出在满足上述条件下能得到的最大开心值是多少。 </p>
<blockquote>
<p><strong>输入描述</strong>：<br>第一行输入两个正整数 $n$和 $k$。<br>接下来 $n$ 行，每行输入两个正整数 $x_{i}$ 和 $y_{i}$，分别表示每个城市的两种属性。<br>$1 \leq n \leq 10^{5}$<br>$1 \leq k \leq 10^{9}$<br>$1 \leq x_{i}, y_{i} \leq 10^{9}$<br><strong>输出描述</strong>：<br>输出一个整数表示答案。</p>
</blockquote>
<blockquote>
<p><strong>示例输入</strong>：<br>5 3<br>1 3<br>2 1<br>5 2<br>3 1<br>4 3<br><strong>示例输出</strong>：<br>6<br><strong>解释</strong>：<br>牛牛可以选择去 3 号， 4 号和 5 号城市进行游玩，并收获最大的开心值。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="2022-07-10-第-301-场周赛"><a href="#2022-07-10-第-301-场周赛" class="headerlink" title="2022-07-10 第 301 场周赛"></a>2022-07-10 第 301 场周赛</h1><p>前一天晚上的双周赛太太太难了，给我整自闭了，问了一下儒哥，也觉得最近周赛难度上升了，跟公司笔试难度不匹配…..<br>然后上午的周赛A了三道，虽然有点慢，但我不自闭了</p>
<h2 id="T1-6112-装满杯子需要的最短总时长"><a href="#T1-6112-装满杯子需要的最短总时长" class="headerlink" title="T1. 6112. 装满杯子需要的最短总时长"></a>T1. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-301/problems/minimum-amount-of-time-to-fill-cups/">6112. 装满杯子需要的最短总时长</a></h2><p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 不同 类型的水或者 <code>1</code> 杯任意类型的水。<br>给你一个下标从 <code>0</code> 开始、长度为 <code>3</code> 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <code>最少</code> 秒数。</p>
<blockquote>
<p><strong>输入</strong>：amount &#x3D; [1,4,2]<br><strong>输出</strong>：4<br><strong>解释</strong>：下面给出一种方案：<br>第 1 秒：装满一杯冷水和一杯温水。<br>第 2 秒：装满一杯温水和一杯热水。<br>第 3 秒：装满一杯温水和一杯热水。<br>第 4 秒：装满一杯温水。<br>可以证明最少需要 4 秒才能装满所有杯子。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：<br><strong>简易贪心</strong> — 每次装水都选择剩余最多的两种类型的杯子。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fillCups</span>(<span class="hljs-params">self, amount: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        time = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">sum</span>(amount) &gt; <span class="hljs-number">0</span>:<br>            amount.sort()<br>            <span class="hljs-keyword">if</span> amount[-<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>:<br>                amount[-<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> amount[-<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>:<br>                amount[-<span class="hljs-number">2</span>] -= <span class="hljs-number">1</span><br>            time += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> time<br></code></pre></td></tr></table></figure>

<h2 id="T2-6113-无限集中的最小数字"><a href="#T2-6113-无限集中的最小数字" class="headerlink" title="T2. 6113. 无限集中的最小数字"></a>T2. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-301/problems/smallest-number-in-infinite-set/">6113. 无限集中的最小数字</a></h2><p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...]</code>。<br>实现 <code>SmallestInfiniteSet</code> 类：</p>
<ul>
<li><code>SmallestInfiniteSet()</code> 初始化 <code>SmallestInfiniteSet</code> 对象以包含 <code>所有</code> 正整数。</li>
<li><code>int popSmallest()</code> 移除 并返回该无限集中的最小整数。</li>
<li><code>void addBack(int num)</code> 如果正整数 <code>num</code> 不 存在于无限集中，则将一个 <code>num</code> 添加 到该无限集中。</li>
</ul>
<blockquote>
<p><strong>输入</strong><br>[“SmallestInfiniteSet”, “addBack”, “popSmallest”, “popSmallest”, “popSmallest”, “addBack”, “popSmallest”, “popSmallest”, “popSmallest”]<br>[[], [2], [], [], [], [1], [], [], []]<br><strong>输出</strong><br>[null, null, 1, 2, 3, null, 1, 4, 5]<br><strong>解释</strong><br>SmallestInfiniteSet smallestInfiniteSet &#x3D; new SmallestInfiniteSet();<br>smallestInfiniteSet.addBack(2);    &#x2F;&#x2F; 2 已经在集合中，所以不做任何变更。<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; 返回 2 ，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; 返回 3 ，并将其从集合中移除。<br>smallestInfiniteSet.addBack(1);    &#x2F;&#x2F; 将 1 添加到该集合中。<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; 返回 1 ，因为 1 在上一步中被添加到集合中，且 1 是最小的整数，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; 返回 4 ，并将其从集合中移除。<br>smallestInfiniteSet.popSmallest(); &#x2F;&#x2F; 返回 5 ，并将其从集合中移除。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：<br><strong>别问，问就是哈希表</strong> — 建立一个 <code>pop_list</code> 记录已被移除的元素。<br>（1） <code>popSmallest()</code> 操作：检验 <code>pop_list</code> 中元素 <code>pop_list[i]</code> 与其下标 <code>i</code> 是否满足 <code>pop_list[i] == i+1</code>，不满足则说明 <code>i+1</code> 还在无限集合中，返回 <code>i+1</code> 即可，否则返回最后一个元素的下一个数字 <code>pop_list[-1]+1</code> ，并将返回结果添加至 <code>pop_list</code> 中。<br>（2）<code>addBack(num)</code> 操作：直接从 <code>pop_list</code> 中移除 <code>num</code> 即可。</p>
</blockquote>
<p>时间复杂度： $O(M \times NlogN)$，$M$ 为调用各方法的次数，空间复杂度： $O(N)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallestInfiniteSet</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.pop_list = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">popSmallest</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> self.pop_list == []:<br>            ret = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            self.pop_list.sort()<br>            n = <span class="hljs-built_in">len</span>(self.pop_list)<br>            i = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span>(i &lt; n):<br>                <span class="hljs-keyword">if</span> self.pop_list[i] != i+<span class="hljs-number">1</span>:<br>                    ret = i+<span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i == n:<br>                ret = self.pop_list[-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        self.pop_list.append(ret)<br>        <span class="hljs-keyword">return</span> ret<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addBack</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> self.pop_list:<br>            self.pop_list.remove(num)<br></code></pre></td></tr></table></figure>

<h2 id="T3-6114-移动片段得到字符串"><a href="#T3-6114-移动片段得到字符串" class="headerlink" title="T3. 6114. 移动片段得到字符串"></a>T3. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-301/problems/move-pieces-to-obtain-a-string/">6114. 移动片段得到字符串</a></h2><p>给你两个字符串 <code>start</code> 和 <code>target</code> ，长度均为 <code>n</code> 。每个字符串 <strong><code>仅</code></strong> 由字符 <code>&#39;L&#39;</code>、<code>&#39;R&#39;</code> 和 <code>&#39;_&#39;</code> 组成，其中：</p>
<ul>
<li>字符 <code>&#39;L&#39;</code> 和 <code>&#39;R&#39;</code> 表示片段，其中片段 <code>&#39;L&#39;</code> 只有在其左侧直接存在一个 <strong><code>空位</code></strong> 时才能向 <strong><code>左</code></strong> 移动，而片段 <code>&#39;R&#39;</code> 只有在其右侧直接存在一个 <strong><code>空位</code></strong> 时才能向 <strong><code>右</code></strong> 移动。</li>
<li>字符 <code>&#39;_&#39;</code> 表示可以被 任意 <code>&#39;L&#39;</code> 或 <code>&#39;R&#39;</code> 片段占据的空位。</li>
</ul>
<p>如果在移动字符串 <code>start</code> 中的片段任意次之后可以得到字符串 <code>target</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<blockquote>
<p><strong>输入</strong>：start &#x3D; “_L__R__R_”, target &#x3D; “L______RR”<br><strong>输出</strong>：true<br><strong>解释</strong>：可以从字符串 start 获得 target ，需要进行下面的移动：<br>-&gt; 将第一个片段向左移动一步，字符串现在变为 “L___R__R_” 。<br>-&gt; 将最后一个片段向右移动一步，字符串现在变为 “L___R___R” 。<br>-&gt; 将第二个片段向右移动散步，字符串现在变为 “L______RR” 。<br>可以从字符串 start 得到 target ，所以返回 true 。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：<br><strong>还是哈希表</strong> — 分别记录 <code>start</code> 和 <code>target</code> 中 <code>&#39;L&#39;</code> 和 <code>&#39;R&#39;</code> 出现的顺序和位置索引，若顺序不一致则直接返回 <code>false</code>，否则进一步判断 <code>start</code> 中每一个 <code>&#39;L&#39;</code> 和 <code>&#39;R&#39;</code> 的位置的合法性。<br>遍历所有 <code>&#39;L&#39;</code> 的索引，对于第 <code>i</code> 个 <code>&#39;L&#39;</code>， 其在 <code>start</code> 中的位置索引不能 <strong><code>小于</code></strong> 在 <code>target</code> 中的索引，即左侧。<br>遍历所有 <code>&#39;R&#39;</code> 的索引，对于第 <code>i</code> 个 <code>&#39;R&#39;</code>， 其在 <code>start</code> 中的位置索引不能 <strong><code>大于</code></strong> 在 <code>target</code> 中的索引，即右侧。</p>
</blockquote>
<p>时间复杂度： $O(N)$，空间复杂度： $O(N)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canChange</span>(<span class="hljs-params">self, start: <span class="hljs-built_in">str</span>, target: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        n = <span class="hljs-built_in">len</span>(start)<br>        s_L, s_R, t_L, t_R = []<br>        s, t = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> start[i] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>                s_L.append(i)<br>                s += <span class="hljs-string">&#x27;L&#x27;</span><br>            <span class="hljs-keyword">if</span> start[i] == <span class="hljs-string">&#x27;R&#x27;</span>:<br>                s_R.append(i)<br>                s += <span class="hljs-string">&#x27;R&#x27;</span><br>            <span class="hljs-keyword">if</span> target[i] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>                t_L.append(i)<br>                t += <span class="hljs-string">&#x27;L&#x27;</span><br>            <span class="hljs-keyword">if</span> target[i] == <span class="hljs-string">&#x27;R&#x27;</span>:<br>                t_R.append(i)<br>                t += <span class="hljs-string">&#x27;R&#x27;</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s_L) != <span class="hljs-built_in">len</span>(t_L) <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(s_R) != <span class="hljs-built_in">len</span>(t_R) <span class="hljs-keyword">or</span> s != t:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s_L)):<br>            <span class="hljs-keyword">if</span> s_L[i] &lt; t_L[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s_R)):<br>            <span class="hljs-keyword">if</span> s_R[i] &gt; t_R[i]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h2 id="T4-6115-统计理想数组的数目"><a href="#T4-6115-统计理想数组的数目" class="headerlink" title="T4. 6115. 统计理想数组的数目"></a>T4. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/weekly-contest-301/problems/count-the-number-of-ideal-arrays/">6115. 统计理想数组的数目</a></h2><p>给你两个整数 <code>n</code> 和 <code>maxValue</code> ，用于描述一个 <strong><code>理想数组</code></strong> 。<br>对于下标从 <code>0</code> 开始、长度为 <code>n</code> 的整数数组 <code>arr</code> ，如果满足以下条件，则认为该数组是一个 <strong><code>理想数组</code></strong> ：</p>
<ul>
<li>每个 <code>arr[i]</code> 都是从 <code>1</code> 到 <code>maxValue</code> 范围内的一个值，其中 <code>0 &lt;= i &lt; n</code> 。</li>
<li>每个 <code>arr[i]</code> 都可以被 <code>arr[i - 1]</code> 整除，其中 <code>0 &lt; i &lt; n</code> 。</li>
</ul>
<p>返回长度为 <code>n</code> 的 <strong><code>不同</code></strong> 理想数组的数目。由于答案可能很大，返回对 <code>10^9 + 7</code> 取余的结果。</p>
<blockquote>
<p><strong>输入</strong>：n &#x3D; 2, maxValue &#x3D; 5<br><strong>输出</strong>：10<br><strong>解释</strong>：存在以下理想数组：<br>-&gt; 以 1 开头的数组（5 个）：[1,1]、[1,2]、[1,3]、[1,4]、[1,5]<br>-&gt; 以 2 开头的数组（2 个）：[2,2]、[2,4]<br>-&gt; 以 3 开头的数组（1 个）：[3,3]<br>-&gt; 以 4 开头的数组（1 个）：[4,4]<br>-&gt; 以 5 开头的数组（1 个）：[5,5]<br>共计 5 + 2 + 1 + 1 + 1 &#x3D; 10 个不同理想数组。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><br></code></pre></td></tr></table></figure>

<hr>
<h1 id="2022-07-09-第-82-场双周赛"><a href="#2022-07-09-第-82-场双周赛" class="headerlink" title="2022-07-09 第 82 场双周赛"></a>2022-07-09 第 82 场双周赛</h1><p>晚上十点半开始的周赛，晚上十一点才想起来自己报名了，第一次参加周赛就给我来了个下马威……</p>
<h2 id="T1-6116-计算布尔二叉树的值"><a href="#T1-6116-计算布尔二叉树的值" class="headerlink" title="T1. 6116. 计算布尔二叉树的值"></a>T1. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-82/problems/evaluate-boolean-binary-tree/">6116. 计算布尔二叉树的值</a></h2><p>给你一棵 <strong><code>完整二叉树</code></strong> 的根，这棵树有以下特征：<br><strong><code>叶子节点</code></strong> 要么值为 <code>0</code> 要么值为 <code>1</code> ，其中 <code>0</code> 表示 <code>False</code> ，<code>1</code> 表示 <code>True</code> 。<br><strong><code>非叶子节点</code></strong> 要么值为 <code>2</code> 要么值为 <code>3</code> ，其中 <code>2</code> 表示逻辑或 <code>OR</code> ，<code>3</code> 表示逻辑与 <code>AND</code> 。<br><strong><code>计算</code></strong> 一个节点的值方式如下：<br>如果节点是个叶子节点，那么节点的 <strong><code>值</code></strong> 为它本身，即 <code>True</code> 或者 <code>False</code> 。<br>否则，**<code>计算</code>** 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 <strong><code>运算</code></strong> 。<br>返回根节点 <code>root</code> 的布尔运算值。<br><strong><code>完整二叉树</code></strong> 是每个节点有 <code>0</code> 个或者 <code>2</code> 个孩子的二叉树。<br><strong><code>叶子节点</code></strong> 是没有孩子的节点。</p>
<p><img src="https://s2.loli.net/2022/07/10/cuzUoGgBhpmRPMA.png"></p>
<blockquote>
<p><strong>输入</strong>：root &#x3D; [2,1,3,null,null,0,1]<br><strong>输出</strong>：true<br><strong>解释</strong>：上图展示了计算过程。<br>AND 与运算节点的值为 False AND True &#x3D; False 。<br>OR 运算节点的值为 True OR False &#x3D; True 。<br>根节点的值为 True ，所以我们返回 true 。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：<br><strong>递归</strong> — 由于是完整二叉树，只包含叶子节点和“伪根节点”，叶子节点直接返回，“伪根节点”返回运算结果。</p>
</blockquote>
<p>时间复杂度： $O(N)$，空间复杂度： $O(1)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluateTree</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">if</span> root.val == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">elif</span> root.val == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> root.val == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> self.evaluateTree(root.left) <span class="hljs-keyword">or</span> self.evaluateTree(root.right)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> self.evaluateTree(root.left) <span class="hljs-keyword">and</span> self.evaluateTree(root.right)<br></code></pre></td></tr></table></figure>

<h2 id="T2-6117-坐上公交的最晚时间"><a href="#T2-6117-坐上公交的最晚时间" class="headerlink" title="T2. 6117. 坐上公交的最晚时间"></a>T2. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-82/problems/the-latest-time-to-catch-a-bus/">6117. 坐上公交的最晚时间</a></h2><p>给你一个下标从 <code>0</code> 开始长度为 <code>n</code> 的整数数组 <code>buses</code> ，其中 <code>buses[i]</code> 表示第 <code>i</code> 辆公交车的出发时间。同时给你一个下标从 <code>0</code> 开始长度为 <code>m</code> 的整数数组 <code>passengers</code> ，其中 <code>passengers[j]</code> 表示第 <code>j</code> 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。<br>给你一个整数 <code>capacity</code> ，表示每辆公交车 <strong><code>最多</code></strong> 能容纳的乘客数目。<br>每位乘客都会搭乘下一辆有座位的公交车。如果你在 <code>y</code> 时刻到达，公交在 <code>x</code> 时刻出发，满足 <code>y &lt;= x</code>  且公交没有满，那么你可以搭乘这一辆公交。**<code>最早</code>** 到达的乘客优先上车。<br>返回你可以搭乘公交车的最晚到达公交站时间。你 <strong><code>不能</code></strong> 跟别的乘客同时刻到达。<br><strong>注意</strong>：数组 <code>buses</code> 和 <code>passengers</code> 不一定是有序的。</p>
<blockquote>
<p><strong>输入</strong>：buses &#x3D; [10,20], passengers &#x3D; [2,17,18,19], capacity &#x3D; 2<br><strong>输出</strong>：16<br><strong>解释</strong>：<br>第 1 辆公交车载着第 1 位乘客。<br>第 2 辆公交车载着你和第 2 位乘客。<br>注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：<br><strong>模拟</strong>：周赛的时候只想着模拟，满脑子都是模拟，最后感觉要过了，提交了四五次都有问题……自闭从此开始</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br></code></pre></td></tr></table></figure>

<h2 id="T3-6118-最小差值平方和"><a href="#T3-6118-最小差值平方和" class="headerlink" title="T3. 6118. 最小差值平方和"></a>T3. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-82/problems/minimum-sum-of-squared-difference/">6118. 最小差值平方和</a></h2><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，长度为 <code>n</code> 。<br>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong><code>差值平方和</code></strong> 定义为所有满足 <code>0 &lt;= i &lt; n</code> 的 <code>(nums1[i] - nums2[i])^2</code> 之和。<br>同时给你两个正整数 <code>k1</code> 和 <code>k2</code> 。你可以将 <code>nums1</code> 中的任意元素 <code>+1</code> 或者 <code>-1</code> 至多 <code>k1</code> 次。类似的，你可以将 <code>nums2</code> 中的任意元素 <code>+1</code> 或者 <code>-1</code> 至多 <code>k2</code> 次。<br>请你返回修改数组 <code>nums1</code> 至多 <code>k1</code> 次且修改数组 <code>nums2</code> 至多 <code>k2</code> 次后的最小 <strong><code>差值平方和</code></strong> 。<br><strong>注意</strong>：你可以将数组中的元素变成 <strong><code>负</code></strong> 整数。</p>
<blockquote>
<p><strong>输入</strong>：nums1 &#x3D; [1,4,10,12], nums2 &#x3D; [5,8,6,9], k1 &#x3D; 1, k2 &#x3D; 1<br><strong>输出</strong>：43<br><strong>解释</strong>：一种得到最小差值平方和的方式为：<br>-&gt; 将 nums1[0] 增加一次。<br>-&gt; 将 nums2[2] 增加一次。<br>最小差值平方和为：<br>(2 - 5)^2 + (4 - 8)^2 + (10 - 7)^2 + (12 - 9)^2 &#x3D; 43 。<br>注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br></code></pre></td></tr></table></figure>

<h2 id="T4-6119-元素值大于变化阈值的子数组"><a href="#T4-6119-元素值大于变化阈值的子数组" class="headerlink" title="T4. 6119. 元素值大于变化阈值的子数组"></a>T4. <a target="_blank" rel="noopener" href="https://leetcode.cn/contest/biweekly-contest-82/problems/subarray-with-elements-greater-than-varying-threshold/">6119. 元素值大于变化阈值的子数组</a></h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。<br>找到长度为 <code>k</code> 的 <code>nums</code> 子数组，满足数组中 <strong><code>每个</code></strong> 元素都 <strong><code>大于</code></strong> <code>threshold / k</code> 。<br>请你返回满足要求的 <strong><code>任意</code></strong> 子数组的 <strong><code>大小</code></strong> 。如果没有这样的子数组，返回 <code>-1</code> 。<br><strong><code>子数组</code></strong> 是数组中一段连续非空的元素序列。</p>
<blockquote>
<p><strong>输入</strong>：nums &#x3D; [6,5,6,5,8], threshold &#x3D; 7<br><strong>输出</strong>：1<br><strong>解释</strong>：子数组 [8] 大小为 1 ，且 8 &gt; 7 &#x2F; 1 &#x3D; 7 。所以返回 1 。<br>注意子数组 [6,5] 大小为 2 ，每个元素都大于 7 &#x2F; 2 &#x3D; 3.5 。<br>类似的，子数组 [6,5,6] ，[6,5,6,5] ，[6,5,6,5,8] 都是符合条件的子数组。<br>所以返回 2, 3, 4 和 5 都可以。</p>
</blockquote>
<blockquote>
<p><strong>解题思路</strong>：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br></code></pre></td></tr></table></figure>

<hr>
<p><em>以下为常用方法，方便速查使用</em></p>
<h1 id="Python篇"><a href="#Python篇" class="headerlink" title="Python篇"></a>Python篇</h1><h2 id="常用数据结构及其操作"><a href="#常用数据结构及其操作" class="headerlink" title="常用数据结构及其操作"></a>常用数据结构及其操作</h2><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p>$\looparrowright$ 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">list</span>.append(obj) - 在列表末尾添加新的对象<br><span class="hljs-built_in">list</span>.count(obj) - 统计某个元素在列表中出现的次数<br><span class="hljs-built_in">list</span>.extend(seq) - 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）<br><span class="hljs-built_in">list</span>.index(obj) - 从列表中找出某个值第一个匹配项的索引位置<br><span class="hljs-built_in">list</span>.insert(index, obj) - 将对象插入列表index的位置<br><span class="hljs-built_in">list</span>.pop([index=-<span class="hljs-number">1</span>]) - 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值<br><span class="hljs-built_in">list</span>.remove(obj) - 移除列表中某个值的第一个匹配项<br><span class="hljs-built_in">list</span>.reverse() - 反向列表中元素<br><span class="hljs-built_in">list</span>.sort(cmp=<span class="hljs-literal">None</span>, key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>) - 对原列表进行排序<br></code></pre></td></tr></table></figure>

<h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><p>$\looparrowright$ 操作大致与列表一致，区别在于<strong>元组的元素不能修改或删除</strong>，只能删除整个元组。</p>
<h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><p>$\looparrowright$ 可变容器模型，可存储任意类型对象。<br>$\looparrowright$ 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-built_in">dict</span>.clear()<br> - 删除字典内所有元素<br><span class="hljs-built_in">dict</span>.copy()<br> - 返回一个字典的浅复制<br><span class="hljs-built_in">dict</span>.fromkeys(seq[, val])<br> - 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值<br><span class="hljs-built_in">dict</span>.get(key, default=<span class="hljs-literal">None</span>)<br> - 返回指定键的值，如果值不在字典中返回default值<br><span class="hljs-built_in">dict</span>.has_key(key)<br> - 如果键在字典<span class="hljs-built_in">dict</span>里返回true，否则返回false<br><span class="hljs-built_in">dict</span>.items()<br> - 以列表返回可遍历的(键, 值)元组数组<br><span class="hljs-built_in">dict</span>.keys()<br> - 以列表返回一个字典所有的键<br><span class="hljs-built_in">dict</span>.setdefault(key, default=<span class="hljs-literal">None</span>)<br> - 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default<br><span class="hljs-built_in">dict</span>.update(dict2)<br> - 把字典dict2的键/值对更新到<span class="hljs-built_in">dict</span>里<br><span class="hljs-built_in">dict</span>.values()<br> - 以列表返回字典中的所有值<br><span class="hljs-built_in">dict</span>.pop(key[,default])<br> - 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值<br><span class="hljs-built_in">dict</span>.popitem()<br> - 返回并删除字典中的最后一对键和值<br></code></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>$\looparrowright$ 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs Python">string.capitalize()<br> - 把字符串的第一个字符大写<br>string.center(width)<br> - 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串<br>string.count(<span class="hljs-built_in">str</span>, beg=<span class="hljs-number">0</span>, end=<span class="hljs-built_in">len</span>(string))<br> - 返回<span class="hljs-built_in">str</span>在string里面出现的次数，如果beg或者end指定则返回指定范围内<span class="hljs-built_in">str</span>出现的次数<br>string.decode(encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>, errors=<span class="hljs-string">&#x27;strict&#x27;</span>)<br> - 以encoding指定的编码格式解码string，如果出错默认报一个ValueError的异常，除非errors指定<span class="hljs-string">&#x27;ignore&#x27;</span>或者<span class="hljs-string">&#x27;replace&#x27;</span><br>string.encode(encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>, errors=<span class="hljs-string">&#x27;strict&#x27;</span>)<br> - 以encoding指定的编码格式编码string，如果出错默认报一个ValueError 的异常，除非errors指定的是<span class="hljs-string">&#x27;ignore&#x27;</span>或者<span class="hljs-string">&#x27;replace&#x27;</span><br>string.endswith(obj, beg=<span class="hljs-number">0</span>, end=<span class="hljs-built_in">len</span>(string))<br> - 检查字符串是否以obj结束，如果beg或者end指定则检查指定的范围内是否以obj 结束，如果是，返回<span class="hljs-literal">True</span>，否则返回<span class="hljs-literal">False</span><br>string.expandtabs(tabsize=<span class="hljs-number">8</span>)<br> - 把字符串string中的tab符号转为空格，tab符号默认的空格数是<span class="hljs-number">8</span><br>string.find(<span class="hljs-built_in">str</span>, beg=<span class="hljs-number">0</span>, end=<span class="hljs-built_in">len</span>(string))<br> - 检测<span class="hljs-built_in">str</span>是否包含在string中，如果beg和end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-<span class="hljs-number">1</span><br>string.<span class="hljs-built_in">format</span>()<br> - 格式化字符串<br>string.index(<span class="hljs-built_in">str</span>, beg=<span class="hljs-number">0</span>, end=<span class="hljs-built_in">len</span>(string))<br> - 跟find()方法一样，只不过如果<span class="hljs-built_in">str</span>不在string中会报一个异常.<br>string.isalnum()<br> - 如果string至少有一个字符并且所有字符都是字母或数字则返回<span class="hljs-literal">True</span>，否则返回<span class="hljs-literal">False</span><br>string.isalpha()<br> - 如果 string 至少有一个字符并且所有字符都是字母则返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span><br>string.isdecimal()<br> - 如果 string 只包含十进制数字则返回 <span class="hljs-literal">True</span> 否则返回 <span class="hljs-literal">False</span>.<br>string.isdigit()<br> - 如果 string 只包含数字则返回 <span class="hljs-literal">True</span> 否则返回 <span class="hljs-literal">False</span>.<br>string.islower()<br> - 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span><br>string.isnumeric()<br> - 如果 string 中只包含数字字符，则返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span><br>string.isspace()<br> - 如果 string 中只包含空格，则返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span>.<br>string.istitle()<br> - 如果 string 是标题化的(见 title())则返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span><br>string.isupper() <br> - 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 <span class="hljs-literal">True</span>，否则返回 <span class="hljs-literal">False</span><br>string.join(seq)<br> - 以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串<br>string.ljust(width)<br> - 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串<br>string.lower()<br> - 转换 string 中所有大写字符为小写.<br>string.lstrip()<br> - 截掉 string 左边的空格<br>string.maketrans(intab, outtab])<br> - 用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。<br><span class="hljs-built_in">max</span>(<span class="hljs-built_in">str</span>)<br> - 返回字符串 <span class="hljs-built_in">str</span> 中最大的字母。<br><span class="hljs-built_in">min</span>(<span class="hljs-built_in">str</span>)<br> - 返回字符串 <span class="hljs-built_in">str</span> 中最小的字母。<br>string.partition(<span class="hljs-built_in">str</span>)<br> - 有点像 find()和 split()的结合体,从 <span class="hljs-built_in">str</span> 出现的第一个位置起,把 字 符 串 string 分 成 一 个 <span class="hljs-number">3</span> 元 素 的 元 组 (string_pre_str,<span class="hljs-built_in">str</span>,string_post_str),如果 string 中不包含<span class="hljs-built_in">str</span> 则 string_pre_str == string.<br>string.replace(str1, str2,  num=string.count(str1))<br> - 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.<br>string.rfind(<span class="hljs-built_in">str</span>, beg=<span class="hljs-number">0</span>,end=<span class="hljs-built_in">len</span>(string))<br> - 类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -<span class="hljs-number">1</span>。<br>string.rindex( <span class="hljs-built_in">str</span>, beg=<span class="hljs-number">0</span>,end=<span class="hljs-built_in">len</span>(string))<br> - 类似于 index()，不过是返回最后一个匹配到的子字符串的索引号。<br>string.rjust(width)<br> - 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串<br>string.rpartition(<span class="hljs-built_in">str</span>)<br> - 类似于 partition()函数,不过是从右边开始查找<br>string.rstrip()<br> - 删除 string 字符串末尾的空格<br>string.split(<span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;&quot;</span>, num=string.count(<span class="hljs-built_in">str</span>))<br> - 以 <span class="hljs-built_in">str</span> 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+<span class="hljs-number">1</span> 个子字符串<br>string.splitlines([keepends])<br> - 按照行(<span class="hljs-string">&#x27;\r&#x27;</span>, <span class="hljs-string">&#x27;\r\n&#x27;</span>, \n<span class="hljs-string">&#x27;)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</span><br><span class="hljs-string">string.startswith(obj, beg=0,end=len(string))</span><br><span class="hljs-string"> - 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</span><br><span class="hljs-string">string.strip([obj])</span><br><span class="hljs-string"> - 在 string 上执行 lstrip()和 rstrip()</span><br><span class="hljs-string">string.swapcase()</span><br><span class="hljs-string"> - 翻转 string 中的大小写</span><br><span class="hljs-string">string.title()</span><br><span class="hljs-string"> - 返回&quot;标题化&quot;的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</span><br><span class="hljs-string">string.translate(str, del=&quot;&quot;)</span><br><span class="hljs-string"> - 根据 str 给出的表(包含 256 个字符)转换 string 的字符，要过滤掉的字符放到 del 参数中</span><br><span class="hljs-string">string.upper()</span><br><span class="hljs-string"> - 转换 string 中的小写字母为大写</span><br><span class="hljs-string">string.zfill(width)</span><br><span class="hljs-string"> - 返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</span><br></code></pre></td></tr></table></figure>

<h2 id="常用内置函数（按函数名首字母排序）"><a href="#常用内置函数（按函数名首字母排序）" class="headerlink" title="常用内置函数（按函数名首字母排序）"></a>常用内置函数（按函数名首字母排序）</h2><ul>
<li><strong>all</strong><br>$\looparrowright$ 判断给定对象中的所有元素是否都为True，如果是返回True，否则返回False（元素为0&#x2F;NULL&#x2F;False），使用示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; all([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]) = True<br><br>&gt;&gt;&gt; all([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]) = False<br><br>&gt;&gt;&gt; all((<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) = False<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>any</strong><br>$\looparrowright$ 判断给定对象中的所有元素是否都为False，如果是返回False，否则返回True，使用示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; any([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]) = True<br><br>&gt;&gt;&gt; any([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]) = True<br><br>&gt;&gt;&gt; any((<span class="hljs-number">0</span>, &#x27;&#x27;, False)) = False<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>cmp</strong><br>$\looparrowright$ 用于比较2个对象x，y，如果x &lt; y，返回-1, 如果x &#x3D;&#x3D; y返回0, 如果x &gt; y返回1。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; cmp(1, 2) = -1<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>enumerate</strong><br>$\looparrowright$ 将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中，使用示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">设seasons = [<span class="hljs-string">&#x27;Spring&#x27;</span>, <span class="hljs-string">&#x27;Summer&#x27;</span>, <span class="hljs-string">&#x27;Fall&#x27;</span>, <span class="hljs-string">&#x27;Winter&#x27;</span>]<br><br>&gt;&gt;&gt; list(enumerate(seasons)) = [(0, <span class="hljs-string">&#x27;Spring&#x27;</span>), (1, <span class="hljs-string">&#x27;Summer&#x27;</span>), (2, <span class="hljs-string">&#x27;Fall&#x27;</span>), (3, <span class="hljs-string">&#x27;Winter&#x27;</span>)]<br><br>&gt;&gt;&gt; list(enumerate(seasons, start=1)) = [(1, <span class="hljs-string">&#x27;Spring&#x27;</span>), (2, <span class="hljs-string">&#x27;Summer&#x27;</span>), (3, <span class="hljs-string">&#x27;Fall&#x27;</span>), (4, <span class="hljs-string">&#x27;Winter&#x27;</span>)]      <span class="hljs-comment"># 下标从 1 开始</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>hash</strong><br>$\looparrowright$ 获取对象（字符串或者数值等）的哈希值，使用示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; <span class="hljs-built_in">hash</span>(<span class="hljs-string">&#x27;test&#x27;</span>) = 2314058222102390712                <span class="hljs-comment"># 字符串</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">hash</span>(1) = 1                                      <span class="hljs-comment"># 数字</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">hash</span>(str([1,2,3])) = 1335416675971793195         <span class="hljs-comment"># 集合</span><br><br>&gt;&gt;&gt; <span class="hljs-built_in">hash</span>(str(sorted(&#123;<span class="hljs-string">&#x27;1&#x27;</span>:1&#125;))) = 7666464346782421378 <span class="hljs-comment"># 字典</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>map</strong><br>$\looparrowright$ 根据提供的函数对指定序列做映射。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; def <span class="hljs-keyword">function</span>(x):<br>		<span class="hljs-built_in">return</span> x ** 2<br><br>&gt;&gt;&gt; map(square, [1,2,3,4,5]) = &lt;map object at 0x100d3d550&gt;              <span class="hljs-comment"># 返回迭代器</span><br><br>&gt;&gt;&gt; list(map(square, [1,2,3,4,5])) = [1, 4, 9, 16, 25]                  <span class="hljs-comment"># 使用 list() 转换为列表</span><br><br>&gt;&gt;&gt; list(map(lambda x: x ** 2, [1, 2, 3, 4, 5])) = [1, 4, 9, 16, 25]    <span class="hljs-comment"># 使用 lambda 匿名函数</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>ord</strong><br>$\looparrowright$ chr()函数（对于8位的ASCII字符串）或unichr()函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的ASCII数值，或者Unicode数值，如果所给的Unicode字符超出了你的Python定义范围，则会引发一个TypeError的异常。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt;ord(<span class="hljs-string">&#x27;a&#x27;</span>) = 97<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>reverse</strong><br>$\looparrowright$ 反向列表元素，使用示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">设List = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br>&gt;&gt;&gt; List.reverse()<br>&gt;&gt;&gt; List = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>set</strong><br>$\looparrowright$ 创建输入对象的无序不重复元素集，set之间可以进行交集（&amp;）、差集（-）、并集（|）运算，使用示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;abcddd&#x27;</span>) = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>sorted</strong><br>$\looparrowright$ 对给定对象进行排序。（sorted(iterable, cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False)）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">设a = [5,7,6,3,4,1,2]<br>&gt;&gt;&gt; sorted(a) = [5, 7, 6, 3, 4, 1, 2]<br><br>设L=[(<span class="hljs-string">&#x27;b&#x27;</span>,2),(<span class="hljs-string">&#x27;a&#x27;</span>,1),(<span class="hljs-string">&#x27;c&#x27;</span>,3),(<span class="hljs-string">&#x27;d&#x27;</span>,4)]<br>&gt;&gt;&gt; sorted(L, cmp=lambda x,y:cmp(x[1],y[1])) = [(<span class="hljs-string">&#x27;a&#x27;</span>, 1), (<span class="hljs-string">&#x27;b&#x27;</span>, 2), (<span class="hljs-string">&#x27;c&#x27;</span>, 3), (<span class="hljs-string">&#x27;d&#x27;</span>, 4)]   <span class="hljs-comment"># 利用cmp函数</span><br>&gt;&gt;&gt; sorted(L, key=lambda x:x[1]) = [(<span class="hljs-string">&#x27;a&#x27;</span>, 1), (<span class="hljs-string">&#x27;b&#x27;</span>, 2), (<span class="hljs-string">&#x27;c&#x27;</span>, 3), (<span class="hljs-string">&#x27;d&#x27;</span>, 4)]               <span class="hljs-comment"># 利用key</span><br><br>设students = [(<span class="hljs-string">&#x27;john&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, 15), (<span class="hljs-string">&#x27;jane&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, 12), (<span class="hljs-string">&#x27;dave&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, 10)]<br>&gt;&gt;&gt; sorted(students, key=lambda s: s[2]) = [(<span class="hljs-string">&#x27;dave&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, 10), (<span class="hljs-string">&#x27;jane&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, 12), (<span class="hljs-string">&#x27;john&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, 15)] <span class="hljs-comment"># 按年龄排序</span><br>&gt;&gt;&gt; sorted(students, key=lambda s: s[2], reverse=True) = [(<span class="hljs-string">&#x27;john&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>, 15), (<span class="hljs-string">&#x27;jane&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, 12), (<span class="hljs-string">&#x27;dave&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, 10)] <span class="hljs-comment"># 降序</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>zip</strong><br>$\looparrowright$ zip([a, b, c, …])，将可迭代对象a，b，c，…打包成元组，返回元组组成的列表，使用示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">设a = [1,2,3], b = [4,5,6], c = [4,5,6,7,8]<br><br>&gt;&gt;&gt; zip(a,b) = [(1, 4), (2, 5), (3, 6)]<br><br>&gt;&gt;&gt; zip(a,c) = [(1, 4), (2, 5), (3, 6)]<br></code></pre></td></tr></table></figure>









<h1 id="C-x2F-C-篇"><a href="#C-x2F-C-篇" class="headerlink" title="C&#x2F;C++篇"></a><strong>C&#x2F;C++篇</strong></h1><h2 id="常用数据结构及其操作-1"><a href="#常用数据结构及其操作-1" class="headerlink" title="常用数据结构及其操作"></a>常用数据结构及其操作</h2><h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><p>$\looparrowright$ 动态大小数组的顺序容器，vector能够存放任意类型的动态数组。可以对序列中的任意元素进行快速直接访问，并利用指针进行操作。<br>$\Rightarrow$ 常用操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">（针对整型数据 vector&lt;int&gt; a）<br><br>（1）插入元素<br>a.push_back() —— 在数组的最后插入元素<br><br>（2）删除数据<br>a.pop_back() —— 删除数组的最后一个数据<br>a.erase —— 删除指针指向的数据项<br>a.clear —— 清空当前的vector<br><br>（3）查找数据<br>a.at(x) —— 获取位置x的元素<br><br>（4）获取向量属性<br>a.size() —— 当前向量的长度<br>a.max_size 得到vector最大长度<br>a.capacity —— 当前vector分配的大小<br>a.begin —— 得到数组头的指针<br>a.end —— 得到数组的最后一个单元+1的指针<br>a.front —— 得到数组头的引用<br>a.back —— 得到数组的最后一个单元的引用<br><br>（5）其它<br>a.rbegin —— 将vector反转后的开始指针返回(其实就是原来的end-1)<br>a.rend —— 将vector反转构的结束指针返回(其实就是原来的begin-1)<br>a.empty —— 判断vector是否为空<br>a.swap —— 与另一个vector交换数据<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">SvyJ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/08/14/032-Leetcode/">http://example.com/2022/08/14/032-Leetcode/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">“干杯( ﾟ-ﾟ)っロ”</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/CPP/">CPP</a></div><div class="post_share"><div class="social-share" data-image="https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/01/028-InterviewQs_IP/" title="For Offersssss! （图像处理篇）"><img class="cover" src="https://s2.loli.net/2022/06/22/2dXg9eDULu3lQsE.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">For Offersssss! （图像处理篇）</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/10/033-SwinTransformer/" title="Swin Transformer 论文阅读笔记"><img class="cover" src="https://s2.loli.net/2022/08/08/Kn2H1Jwq8ucS4lF.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Swin Transformer 论文阅读笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/25/030-InterviewQs_Leetcode/" title="For Offersssss! （数据结构与算法篇）"><img class="cover" src="https://s2.loli.net/2022/06/22/2dXg9eDULu3lQsE.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">For Offersssss! （数据结构与算法篇）</div></div></a></div><div><a href="/2022/09/25/026-InterviewQs_ML/" title="For Offersssss! （机器学习篇）"><img class="cover" src="https://s2.loli.net/2022/06/22/2dXg9eDULu3lQsE.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">For Offersssss! （机器学习篇）</div></div></a></div><div><a href="/2022/09/17/027-InterviewQs_DL/" title="For Offersssss! （深度学习篇）"><img class="cover" src="https://s2.loli.net/2022/06/22/2dXg9eDULu3lQsE.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-17</div><div class="title">For Offersssss! （深度学习篇）</div></div></a></div><div><a href="/2022/09/06/029-InterviewQs_Python/" title="For Offersssss! （Linux与Python篇）"><img class="cover" src="https://s2.loli.net/2022/06/22/2dXg9eDULu3lQsE.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-06</div><div class="title">For Offersssss! （Linux与Python篇）</div></div></a></div><div><a href="/2022/09/01/028-InterviewQs_IP/" title="For Offersssss! （图像处理篇）"><img class="cover" src="https://s2.loli.net/2022/06/22/2dXg9eDULu3lQsE.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-01</div><div class="title">For Offersssss! （图像处理篇）</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-08-14-%E7%AC%AC-306-%E5%9C%BA%E5%91%A8%E8%B5%9B"><span class="toc-number">1.</span> <span class="toc-text">2022-08-14 第 306 场周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6148-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">T1 6148. 矩阵中的局部最大值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6149-%E8%BE%B9%E7%A7%AF%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">T2 6149. 边积分最高的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6150-%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%BC%8F%E4%B8%B2%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">1.3.</span> <span class="toc-text">T3 6150. 根据模式串构造最小数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6151-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">T4 6151. 统计特殊整数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-08-07-%E7%AC%AC-305-%E5%9C%BA%E5%91%A8%E8%B5%9B"><span class="toc-number">2.</span> <span class="toc-text">2022-08-07 第 305 场周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6136-%E7%AE%97%E6%9C%AF%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.1.</span> <span class="toc-text">T1 6136. 算术三元组的数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6139-%E5%8F%97%E9%99%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.2.</span> <span class="toc-text">T2 6139. 受限条件下可到达节点的数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6137-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86"><span class="toc-number">2.3.</span> <span class="toc-text">T3 6137. 检查数组是否存在有效划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6138-%E6%9C%80%E9%95%BF%E7%90%86%E6%83%B3%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">T4 6138. 最长理想子序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-07-31-%E7%AC%AC-304-%E5%9C%BA%E5%91%A8%E8%B5%9B"><span class="toc-number">3.</span> <span class="toc-text">2022-07-31 第 304 场周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6132-%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E7%AD%89%E4%BA%8E%E9%9B%B6"><span class="toc-number">3.1.</span> <span class="toc-text">T1 6132. 使数组中所有元素都等于零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6133-%E5%88%86%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">T2 6133. 分组的最大数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6134-%E6%89%BE%E5%88%B0%E7%A6%BB%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E6%9C%80%E8%BF%91%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">T3 6134. 找到离给定两个节点最近的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6135-%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E7%8E%AF"><span class="toc-number">3.4.</span> <span class="toc-text">T4 6135. 图中的最长环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-07-24-%E7%AC%AC-303-%E5%9C%BA%E5%91%A8%E8%B5%9B"><span class="toc-number">4.</span> <span class="toc-text">2022-07-24 第 303 场周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6124-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E6%AF%8D"><span class="toc-number">4.1.</span> <span class="toc-text">T1 6124. 第一个出现两次的字母</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6125-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9"><span class="toc-number">4.2.</span> <span class="toc-text">T2 6125. 相等行列对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6126-%E8%AE%BE%E8%AE%A1%E9%A3%9F%E7%89%A9%E8%AF%84%E5%88%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.</span> <span class="toc-text">T3 6126. 设计食物评分系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6127-%E4%BC%98%E8%B4%A8%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">4.4.</span> <span class="toc-text">T4 6127. 优质数对的数目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-07-23-%E7%AC%AC-83-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B"><span class="toc-number">5.</span> <span class="toc-text">2022-07-23 第 83 场双周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6128-%E6%9C%80%E5%A5%BD%E7%9A%84%E6%89%91%E5%85%8B%E6%89%8B%E7%89%8C"><span class="toc-number">5.1.</span> <span class="toc-text">T1 6128. 最好的扑克手牌</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6129-%E5%85%A8-0-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">5.2.</span> <span class="toc-text">T2 6129. 全 0 子数组的数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6130-%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E5%AE%B9%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.3.</span> <span class="toc-text">T3 6130. 设计数字容器系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6131-%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E7%9F%AD%E9%AA%B0%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.4.</span> <span class="toc-text">T4 6131. 不可能得到的最短骰子序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-07-17-%E7%AC%AC-302-%E5%9C%BA%E5%91%A8%E8%B5%9B"><span class="toc-number">6.</span> <span class="toc-text">2022-07-17 第 302 场周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6120-%E6%95%B0%E7%BB%84%E8%83%BD%E5%BD%A2%E6%88%90%E5%A4%9A%E5%B0%91%E6%95%B0%E5%AF%B9"><span class="toc-number">6.1.</span> <span class="toc-text">T1 6120. 数组能形成多少数对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6164-%E6%95%B0%E4%BD%8D%E5%92%8C%E7%9B%B8%E7%AD%89%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">6.2.</span> <span class="toc-text">T2 6164. 数位和相等数对的最大和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6121-%E8%A3%81%E5%89%AA%E6%95%B0%E5%AD%97%E5%90%8E%E6%9F%A5%E8%AF%A2%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">6.3.</span> <span class="toc-text">T3 6121. 裁剪数字后查询第 K 小的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6122-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">T4 6122. 使数组可以被整除的最少删除次数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-07-13-%E8%94%9A%E6%9D%A5-2023-%E5%B1%8A%E6%8F%90%E5%89%8D%E6%89%B9%E7%AC%94%E8%AF%95"><span class="toc-number">7.</span> <span class="toc-text">2022-07-13 蔚来 2023 届提前批笔试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-%E6%9C%80%E5%B0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">T2 最少的操作次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-%E7%89%9B%E7%89%9B%E7%9A%84%E5%BC%80%E5%BF%83%E6%97%85%E8%A1%8C"><span class="toc-number">7.2.</span> <span class="toc-text">T3 牛牛的开心旅行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-07-10-%E7%AC%AC-301-%E5%9C%BA%E5%91%A8%E8%B5%9B"><span class="toc-number">8.</span> <span class="toc-text">2022-07-10 第 301 场周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6112-%E8%A3%85%E6%BB%A1%E6%9D%AF%E5%AD%90%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E7%9F%AD%E6%80%BB%E6%97%B6%E9%95%BF"><span class="toc-number">8.1.</span> <span class="toc-text">T1. 6112. 装满杯子需要的最短总时长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6113-%E6%97%A0%E9%99%90%E9%9B%86%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">8.2.</span> <span class="toc-text">T2. 6113. 无限集中的最小数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6114-%E7%A7%BB%E5%8A%A8%E7%89%87%E6%AE%B5%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.3.</span> <span class="toc-text">T3. 6114. 移动片段得到字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6115-%E7%BB%9F%E8%AE%A1%E7%90%86%E6%83%B3%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">8.4.</span> <span class="toc-text">T4. 6115. 统计理想数组的数目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-07-09-%E7%AC%AC-82-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B"><span class="toc-number">9.</span> <span class="toc-text">2022-07-09 第 82 场双周赛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#T1-6116-%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B0%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%80%BC"><span class="toc-number">9.1.</span> <span class="toc-text">T1. 6116. 计算布尔二叉树的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T2-6117-%E5%9D%90%E4%B8%8A%E5%85%AC%E4%BA%A4%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4"><span class="toc-number">9.2.</span> <span class="toc-text">T2. 6117. 坐上公交的最晚时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T3-6118-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E5%B9%B3%E6%96%B9%E5%92%8C"><span class="toc-number">9.3.</span> <span class="toc-text">T3. 6118. 最小差值平方和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T4-6119-%E5%85%83%E7%B4%A0%E5%80%BC%E5%A4%A7%E4%BA%8E%E5%8F%98%E5%8C%96%E9%98%88%E5%80%BC%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">9.4.</span> <span class="toc-text">T4. 6119. 元素值大于变化阈值的子数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E7%AF%87"><span class="toc-number">10.</span> <span class="toc-text">Python篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.</span> <span class="toc-text">常用数据结构及其操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-number">10.1.1.</span> <span class="toc-text">列表（List）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%EF%BC%88Tuple%EF%BC%89"><span class="toc-number">10.1.2.</span> <span class="toc-text">元组（Tuple）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%EF%BC%88Dictionary%EF%BC%89"><span class="toc-number">10.1.3.</span> <span class="toc-text">字典（Dictionary）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.1.4.</span> <span class="toc-text">字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%EF%BC%88%E6%8C%89%E5%87%BD%E6%95%B0%E5%90%8D%E9%A6%96%E5%AD%97%E6%AF%8D%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">常用内置函数（按函数名首字母排序）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-x2F-C-%E7%AF%87"><span class="toc-number">11.</span> <span class="toc-text">C&#x2F;C++篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C-1"><span class="toc-number">11.1.</span> <span class="toc-text">常用数据结构及其操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%EF%BC%88Vector%EF%BC%89"><span class="toc-number">11.1.1.</span> <span class="toc-text">向量（Vector）</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By SvyJ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello, Stranger~</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'e5bWQMoOycxPCdtTvxkPGJ0d-gzGzoHsz',
      appKey: 'peE7twywLp5HcdBx6gmKQYUH',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>